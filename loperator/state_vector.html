<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>State vectors &mdash; libcommute 0.7.2 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Finding invariant subspaces of a linear operator" href="space_partition.html" />
    <link rel="prev" title="Advanced: Linear operator representation of a user-defined algebra" href="monomial_action.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            libcommute
              <img src="../_static/logo_small.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.7.2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">How to use <em>libcommute</em> in your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expression/index.html">Domain-Specific Language for polynomial expressions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tools for exact diagonalization</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="hilbert_space.html">Finite-dimensional Hilbert spaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="loperator.html">Linear operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="monomial_action.html">Advanced: Linear operator representation of a user-defined algebra</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">State vectors</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#statevector-concept"><code class="docutils literal notranslate"><span class="pre">StateVector</span></code> concept</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sparse-state-vector">Sparse state vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mapped-basis-view">Mapped basis view</a></li>
<li class="toctree-l3"><a class="reference internal" href="#n-fermion-sector-views">N-fermion sector views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="space_partition.html">Finding invariant subspaces of a linear operator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../search.html">Search Page</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">libcommute</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Tools for exact diagonalization</a></li>
      <li class="breadcrumb-item active">State vectors</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/loperator/state_vector.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="state-vectors">
<span id="id1"></span><h1>State vectors<a class="headerlink" href="#state-vectors" title="Permalink to this heading"></a></h1>
<section id="statevector-concept">
<span id="state-vector"></span><h2><code class="docutils literal notranslate"><span class="pre">StateVector</span></code> concept<a class="headerlink" href="#statevector-concept" title="Permalink to this heading"></a></h2>
<p>Let us say we want to make type <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">SV</span></code> a <em>libcommute</em>-compatible state
vector type so that <a class="reference internal" href="loperator.html#loperator"><span class="std std-ref">linear operators</span></a> can act on instances
of <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">SV</span></code>. For this we have to make <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">SV</span></code> model the <code class="docutils literal notranslate"><span class="pre">StateVector</span></code>
concept.
In a nutshell, a <code class="docutils literal notranslate"><span class="pre">StateVector</span></code> type is a one-dimensional array of numbers
(quantum amplitudes) allowing integer indexing and implementing a certain
interface. Elements of the array do not have to be stored contiguously.
Acceptable index values must be at least 64-bit wide unsigned integers since
<em>libcommute</em> uses the following type for basis state indexing.</p>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute13sv_index_typeE">
<span id="_CPPv3N10libcommute13sv_index_typeE"></span><span id="_CPPv2N10libcommute13sv_index_typeE"></span><span class="k"><span class="pre">using</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sv_index_type</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">uint64_t</span></span><a class="headerlink" href="#_CPPv4N10libcommute13sv_index_typeE" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/state_vector.hpp&gt;</em></p>
<p>Type of basis state indices.</p>
</dd></dl>

<p>The table below shows the interface (a set of free functions and a
metafunction) that needs be implemented for an object <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span> of type
<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">SV</span></code>.</p>
<p><em>libcommute</em> provides an implementation of the <code class="docutils literal notranslate"><span class="pre">StateVector</span></code> concept for
<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::vector</span></code> (see <em>&lt;libcommute/loperator/state_vector.hpp&gt;</em>).</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Function/metafunction</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Implementation for <span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span></span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">element_type</span><span class="p">&lt;</span><span class="n">SV</span><span class="p">&gt;</span><span class="p">::</span><span class="n">type</span></span></p></td>
<td><p>Type of the elements.</p></td>
<td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">T</span></span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">get_element</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span></span></p></td>
<td><p>Return the <span class="cpp-expr sig sig-inline cpp"><span class="n">n</span></span>-th element of <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span>.</p></td>
<td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></span></p></td>
</tr>
<tr class="row-even"><td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">update_add_element</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span></span></p></td>
<td><p>Add a value of some type <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">U</span></code> to the <span class="cpp-expr sig sig-inline cpp"><span class="n">n</span></span>-th element of
<span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span>.</p></td>
<td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">value</span></span> or <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sv</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">value</span></span></p>
<p>The compound-assignment from type <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">U</span></code> will be used
whenever <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span>’s elements support it. Otherwise, the implementation
will fall back to the simple addition.</p>
</td>
</tr>
<tr class="row-odd"><td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">set_zeros</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span></span></p></td>
<td><p>Fill <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span> with zeros.</p></td>
<td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">fill</span><span class="p">(</span><span class="n">sv</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">sv</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">)</span></span>.</p>
<p>The zero value is created by
<span class="cpp-expr sig sig-inline cpp"><span class="n">make_const</span><span class="p">(</span><span class="m">0</span><span class="p">)</span></span> as described in “<a class="reference internal" href="../expression/expression.html#custom-scalar-type"><span class="std std-ref">Custom scalar types</span></a>”.</p>
</td>
</tr>
<tr class="row-even"><td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">zeros_like</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span></span></p></td>
<td><p>Return an object of the same type and size as <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span> but filled with
zeros.</p></td>
<td><p>Creates a new object as <span class="cpp-expr sig sig-inline cpp"><span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span><span class="p">(</span><span class="n">sv</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="p">)</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">)</span></span>.</p></td>
</tr>
<tr class="row-odd"><td><p><span class="cpp-expr sig sig-inline cpp"><span class="n">foreach</span><span class="p">(</span><span class="n">sv</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="p">)</span></span></p></td>
<td><p>Apply a function-like object <span class="cpp-expr sig sig-inline cpp"><span class="n">f</span></span> to all basis state index/non-zero
element pairs <span class="cpp-expr sig sig-inline cpp"><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span></span> in <span class="cpp-expr sig sig-inline cpp"><span class="n">sv</span></span>.</p></td>
<td><p>In a for-loop, calls <span class="cpp-expr sig sig-inline cpp"><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span></span> for all non-zero elements <span class="cpp-expr sig sig-inline cpp"><span class="n">a</span></span>
as detected by <span class="cpp-expr sig sig-inline cpp"><span class="n">is_zero</span><span class="p">(</span><span class="p">)</span></span> (see “<a class="reference internal" href="../expression/expression.html#custom-scalar-type"><span class="std std-ref">Custom scalar types</span></a>”).</p></td>
</tr>
</tbody>
</table>
<p>Inclusion of <em>&lt;libcommute/loperator/state_vector_eigen3.hpp&gt;</em> makes some
<a class="reference external" href="https://eigen.tuxfamily.org/">Eigen 3</a> types (<a class="reference external" href="https://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html#TutorialMatrixVectors">column vectors</a>,
<a class="reference external" href="https://eigen.tuxfamily.org/dox/classEigen_1_1VectorBlock.html">vector blocks</a>,
<a class="reference external" href="https://eigen.tuxfamily.org/dox/group__TutorialBlockOperations.html#TutorialBlockOperationsSyntaxColumnRows">column-like matrix blocks</a> and one-dimensional <a class="reference external" href="https://eigen.tuxfamily.org/dox/classEigen_1_1Map.html">Eigen::Map views</a>)
compatible with the <code class="docutils literal notranslate"><span class="pre">StateVector</span></code> concept as well.</p>
</section>
<section id="sparse-state-vector">
<span id="id2"></span><h2>Sparse state vector<a class="headerlink" href="#sparse-state-vector" title="Permalink to this heading"></a></h2>
<p><a class="reference internal" href="#_CPPv4I0EN10libcommute19sparse_state_vectorE" title="libcommute::sparse_state_vector"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">sparse_state_vector</span></code></a> is a state vector that saves memory by storing only
the non-zero elements. It is essentially a wrapper around
<code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::unordered_map</span></code> modelling the <code class="docutils literal notranslate"><span class="pre">StateVector</span></code> concept. Here, we show
only the part of its interface not covered by <code class="docutils literal notranslate"><span class="pre">StateVector</span></code>.</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute19sparse_state_vectorE">
<span id="_CPPv3I0EN10libcommute19sparse_state_vectorE"></span><span id="_CPPv2I0EN10libcommute19sparse_state_vectorE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ScalarType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sparse_state_vector</span></span></span><a class="headerlink" href="#_CPPv4I0EN10libcommute19sparse_state_vectorE" title="Permalink to this definition"></a><br /></dt>
<dd><p>State vector with a sparse storage of elements (quantum amplitudes).
<span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute19sparse_state_vectorE" title="libcommute::sparse_state_vector::ScalarType"><span class="n">ScalarType</span></a></span> is the type of the elements.</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute19sparse_state_vector19sparse_state_vectorEv">
<span id="_CPPv3N10libcommute19sparse_state_vector19sparse_state_vectorEv"></span><span id="_CPPv2N10libcommute19sparse_state_vector19sparse_state_vectorEv"></span><span id="libcommute::sparse_state_vector::sparse_state_vector"></span><span class="sig-name descname"><span class="n"><span class="pre">sparse_state_vector</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">delete</span></span><a class="headerlink" href="#_CPPv4N10libcommute19sparse_state_vector19sparse_state_vectorEv" title="Permalink to this definition"></a><br /></dt>
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute19sparse_state_vector19sparse_state_vectorE13sv_index_type">
<span id="_CPPv3N10libcommute19sparse_state_vector19sparse_state_vectorE13sv_index_type"></span><span id="_CPPv2N10libcommute19sparse_state_vector19sparse_state_vectorE13sv_index_type"></span><span id="libcommute::sparse_state_vector::sparse_state_vector__sv_index_type"></span><span class="sig-name descname"><span class="n"><span class="pre">sparse_state_vector</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute19sparse_state_vector19sparse_state_vectorE13sv_index_type" title="Permalink to this definition"></a><br /></dt>
<dd><p>Construct a zero (empty) sparse vector with a given <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4N10libcommute19sparse_state_vector19sparse_state_vectorE13sv_index_type" title="libcommute::sparse_state_vector::sparse_state_vector::size"><span class="n">size</span></a></span> –
dimension of the corresponding Hilbert space.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute19sparse_state_vector4sizeEv">
<span id="_CPPv3NK10libcommute19sparse_state_vector4sizeEv"></span><span id="_CPPv2NK10libcommute19sparse_state_vector4sizeEv"></span><span id="libcommute::sparse_state_vector::sizeC"></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute19sparse_state_vector4sizeEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size (dimension) of the vector.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute19sparse_state_vectorixE13sv_index_type">
<span id="_CPPv3N10libcommute19sparse_state_vectorixE13sv_index_type"></span><span id="_CPPv2N10libcommute19sparse_state_vectorixE13sv_index_type"></span><span id="libcommute::sparse_state_vector::subscript-operator__sv_index_type"></span><a class="reference internal" href="#_CPPv4I0EN10libcommute19sparse_state_vectorE" title="libcommute::sparse_state_vector::ScalarType"><span class="n"><span class="pre">ScalarType</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="sig-name descname"><span class="k"><span class="pre">operator</span></span><span class="o"><span class="pre">[]</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute19sparse_state_vectorixE13sv_index_type" title="Permalink to this definition"></a><br /></dt>
<dd><p>Access the <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4N10libcommute19sparse_state_vectorixE13sv_index_type" title="libcommute::sparse_state_vector::operator[]::n"><span class="n">n</span></a></span>-th element. If it is zero (missing from the storage),
then a new value-initialized element will be inserted and a reference to
it will be returned.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Improper use of this method may result in zero elements being stored in
the unordered map. Only the non-zero values should be assigned to the
references returned by it.</p>
</div>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute19sparse_state_vector10n_nonzerosEv">
<span id="_CPPv3NK10libcommute19sparse_state_vector10n_nonzerosEv"></span><span id="_CPPv2NK10libcommute19sparse_state_vector10n_nonzerosEv"></span><span id="libcommute::sparse_state_vector::n_nonzerosC"></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nonzeros</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute19sparse_state_vector10n_nonzerosEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Get the number of non-zero (stored) elements.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute19sparse_state_vector5pruneEv">
<span id="_CPPv3N10libcommute19sparse_state_vector5pruneEv"></span><span id="_CPPv2N10libcommute19sparse_state_vector5pruneEv"></span><span id="libcommute::sparse_state_vector::prune"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">prune</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute19sparse_state_vector5pruneEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Remove all zero elements (as defined by
<a class="reference internal" href="../expression/expression.html#custom-scalar-type"><span class="std std-ref">scalar_traits&lt;ScalarType&gt;::is_zero()</span></a>)
from the unordered map.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute19sparse_state_vector5pruneEvRR14UnaryPredicate">
<span id="_CPPv3I0EN10libcommute19sparse_state_vector5pruneERR14UnaryPredicate"></span><span id="_CPPv2I0EN10libcommute19sparse_state_vector5pruneERR14UnaryPredicate"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UnaryPredicate</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">prune</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN10libcommute19sparse_state_vector5pruneEvRR14UnaryPredicate" title="libcommute::sparse_state_vector::prune::UnaryPredicate"><span class="n"><span class="pre">UnaryPredicate</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN10libcommute19sparse_state_vector5pruneEvRR14UnaryPredicate" title="Permalink to this definition"></a><br /></dt>
<dd><p>Remove unordered map elements (amplitudes) for which predicate <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute19sparse_state_vector5pruneEvRR14UnaryPredicate" title="libcommute::sparse_state_vector::prune::p"><span class="n">p</span></a></span>
returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</dd></dl>

</dd></dl>

</section>
<section id="mapped-basis-view">
<span id="id3"></span><h2>Mapped basis view<a class="headerlink" href="#mapped-basis-view" title="Permalink to this heading"></a></h2>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> is another utility type modelling the <code class="docutils literal notranslate"><span class="pre">StateVector</span></code>
concept. It is a view of a state vector, which translates basis state
index arguments of <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">get_element()</span></code> and <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">update_add_element()</span></code>
according to a predefined map <a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sv_index_type</span></code></a> -&gt; <a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sv_index_type</span></code></a>.
The element access functions throw <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">std::out_of_range</span></code> if their index
argument is missing from the map.</p>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> can be used in situations
where a <a class="reference internal" href="loperator.html#loperator"><span class="std std-ref">linear operator</span></a> acts in a small subspace of
a full Hilbert space, and it is desirable to store vector components only within
that subspace. Such a situation naturally emerges when working with
<a class="reference internal" href="space_partition.html#space-partition"><span class="std std-ref">invariant subspaces of operators</span></a>.</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0_bEN10libcommute17mapped_basis_viewE">
<span id="_CPPv3I0_bEN10libcommute17mapped_basis_viewE"></span><span id="_CPPv2I0_bEN10libcommute17mapped_basis_viewE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Ref</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">true</span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mapped_basis_view</span></span></span><a class="headerlink" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="Permalink to this definition"></a><br /></dt>
<dd><p>View of a <a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view::StateVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StateVector</span></code></a> object that translates basis state indices
according to a certain mapping.</p>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view::StateVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StateVector</span></code></a> - type of the underlying state vector object. Defining a
read-only view (such that prohibits <span class="cpp-expr sig sig-inline cpp"><span class="n">update_add_element</span><span class="p">(</span><span class="p">)</span></span> operations)
requires using a <code class="docutils literal notranslate"><span class="pre">const</span></code>-qualified type here. For example, one can use
<code class="docutils literal notranslate"><span class="pre">StateVector</span> <span class="pre">=</span> <span class="pre">std::vector&lt;double&gt;</span></code> for a read-write view, and
<code class="docutils literal notranslate"><span class="pre">StateVector</span> <span class="pre">=</span> <span class="pre">const</span> <span class="pre">std::vector&lt;double&gt;</span></code> for a read-only view.</p>
<p id="mapped-basis-view-ref"><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view::Ref"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">Ref</span></code></a> - by default, <a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a>
stores a reference to the underlying state vector. Setting this option to
<code class="docutils literal notranslate"><span class="pre">false</span></code> will result in a copy being created and stored instead. This feature
can be useful when the underlying type is already a view-like object similar
to <code class="docutils literal notranslate"><span class="pre">Eigen::Map</span></code>.</p>
</dd></dl>

<p>The mapped basis views should always be constructed by means of a special
factory class <a class="reference internal" href="#_CPPv4N10libcommute12basis_mapperE" title="libcommute::basis_mapper"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">basis_mapper</span></code></a> and its methods
<a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper9make_viewE17mapped_basis_viewI11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_view"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basis_mapper::</span> <span class="pre">make_view()</span></code></a>/<a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_const_view"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">basis_mapper::make_const_view()</span></code></a>.</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute12basis_mapperE">
<span id="_CPPv3N10libcommute12basis_mapperE"></span><span id="_CPPv2N10libcommute12basis_mapperE"></span><span id="libcommute::basis_mapper"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">basis_mapper</span></span></span><a class="headerlink" href="#_CPPv4N10libcommute12basis_mapperE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Factory class for <a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a>.</p>
<p class="rubric">Constructors</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute12basis_mapper12basis_mapperERKNSt6vectorI13sv_index_typeEE">
<span id="_CPPv3N10libcommute12basis_mapper12basis_mapperERKNSt6vectorI13sv_index_typeEE"></span><span id="_CPPv2N10libcommute12basis_mapper12basis_mapperERKNSt6vectorI13sv_index_typeEE"></span><span id="libcommute::basis_mapper::basis_mapper__std::vector:sv_index_type:CR"></span><span class="sig-name descname"><span class="n"><span class="pre">basis_mapper</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">basis_state_indices</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute12basis_mapper12basis_mapperERKNSt6vectorI13sv_index_typeEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Build a mapping from a list of basis states <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4N10libcommute12basis_mapper12basis_mapperERKNSt6vectorI13sv_index_typeEE" title="libcommute::basis_mapper::basis_mapper::basis_state_indices"><span class="n">basis_state_indices</span></a></span>
to their positions within the list.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">sv_index_type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basis_indices</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">};</span>
<span class="n">basis_mapper</span><span class="w"> </span><span class="nf">mapper</span><span class="p">(</span><span class="n">basis_indices</span><span class="p">);</span>

<span class="c1">// Views created by &#39;mapper&#39; will translate basis state indices</span>
<span class="c1">// according to</span>
<span class="c1">// 0 -&gt; std::out_of_range</span>
<span class="c1">// 1 -&gt; std::out_of_range</span>
<span class="c1">// 2 -&gt; std::out_of_range</span>
<span class="c1">// 3 -&gt; 0</span>
<span class="c1">// 4 -&gt; std::out_of_range</span>
<span class="c1">// 5 -&gt; 1</span>
<span class="c1">// 6 -&gt; 2</span>
<span class="c1">// 7 -&gt; std::out_of_range</span>
<span class="c1">// ...</span>
</pre></div>
</div>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType">
<span id="_CPPv3I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType"></span><span id="_CPPv2I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">LOpScalarType</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">LOpAlgebraIDs</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="sig-name descname"><span class="n"><span class="pre">basis_mapper</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="loperator.html#_CPPv4I0_DpiEN10libcommute9loperatorE" title="libcommute::loperator"><span class="n"><span class="pre">loperator</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType" title="libcommute::basis_mapper::basis_mapper::LOpScalarType"><span class="n"><span class="pre">LOpScalarType</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType" title="libcommute::basis_mapper::basis_mapper::LOpAlgebraIDs"><span class="n"><span class="pre">LOpAlgebraIDs</span></span></a><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">O</span></span>, <a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType" title="libcommute::basis_mapper::basis_mapper::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType" title="Permalink to this definition"></a><br /></dt>
<dd><p>Build a mapping from a set of all basis states contributing to
<span class="math notranslate nohighlight">\(\hat O|0\rangle\)</span>.</p>
<p>Operator <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType" title="libcommute::basis_mapper::basis_mapper::O"><span class="n">O</span></a></span> acts in the Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERK9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsERK6HSType" title="libcommute::basis_mapper::basis_mapper::hs"><span class="n">hs</span></a></span>.
<span class="math notranslate nohighlight">\(|0\rangle\)</span> is the basis state with index 0 (‘vacuum’ state in
the case of fermions and bosons).
Mapped values are assigned continuously starting from 0 without any specific
order.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej">
<span id="_CPPv3I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej"></span><span id="_CPPv2I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">LOpScalarType</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="p"><span class="pre">...</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">LOpAlgebraIDs</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="sig-name descname"><span class="n"><span class="pre">basis_mapper</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="loperator.html#_CPPv4I0_DpiEN10libcommute9loperatorE" title="libcommute::loperator"><span class="n"><span class="pre">loperator</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej" title="libcommute::basis_mapper::basis_mapper::LOpScalarType"><span class="n"><span class="pre">LOpScalarType</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej" title="libcommute::basis_mapper::basis_mapper::LOpAlgebraIDs"><span class="n"><span class="pre">LOpAlgebraIDs</span></span></a><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">O_list</span></span>, <a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej" title="libcommute::basis_mapper::basis_mapper::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej" title="Permalink to this definition"></a><br /></dt>
<dd><p>Given a list of operators
<span class="math notranslate nohighlight">\(\{\hat O_1, \hat O_2, \hat O_3, \ldots, \hat O_M\}\)</span>, build a mapping
from all basis states contributing to all states
<span class="math notranslate nohighlight">\(\hat O_1^{n_1} \hat O_2^{n_2} \ldots \hat O_M^{n_M} |0\rangle\)</span>,
where <span class="math notranslate nohighlight">\(n_m \geq 0\)</span> and <span class="math notranslate nohighlight">\(\sum_{m=1}^M n_M = N\)</span>.</p>
<p>Operators in <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej" title="libcommute::basis_mapper::basis_mapper::O_list"><span class="n">O_list</span></a></span> act in the Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00_DpiEN10libcommute12basis_mapper12basis_mapperERKNSt6vectorI9loperatorI13LOpScalarTypeDp13LOpAlgebraIDsEEERK6HSTypej" title="libcommute::basis_mapper::basis_mapper::hs"><span class="n">hs</span></a></span>.
<span class="math notranslate nohighlight">\(|0\rangle\)</span> is the basis state with index 0 (‘vacuum’ state in
the case of fermions and bosons).
Mapped values are assigned continuously starting from 0 without any specific
order.</p>
<p>This constructor is useful to create a mapping from a fixed-particle-number
subspace of a fermionic/bosonic Hilbert space.</p>
</dd></dl>

<p class="rubric"><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> factory functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0ENK10libcommute12basis_mapper9make_viewE17mapped_basis_viewI11StateVectorERR11StateVector">
<span id="_CPPv3I0ENK10libcommute12basis_mapper9make_viewERR11StateVector"></span><span id="_CPPv2I0ENK10libcommute12basis_mapper9make_viewERR11StateVector"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><span class="n"><span class="pre">mapped_basis_view</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper9make_viewE17mapped_basis_viewI11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">make_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper9make_viewE17mapped_basis_viewI11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4I0ENK10libcommute12basis_mapper9make_viewE17mapped_basis_viewI11StateVectorERR11StateVector" title="Permalink to this definition"></a><br /></dt>
<dt class="sig sig-object cpp" id="_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector">
<span id="_CPPv3I0ENK10libcommute12basis_mapper15make_const_viewERR11StateVector"></span><span id="_CPPv2I0ENK10libcommute12basis_mapper15make_const_viewERR11StateVector"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><span class="n"><span class="pre">mapped_basis_view</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_const_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">make_const_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_const_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="Permalink to this definition"></a><br /></dt>
<dd><p>Make a read/write or constant view of <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_const_view::sv"><span class="n">sv</span></a></span>.
Constant views will not be accepted by <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">update_add_element()</span></code>.
If <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_const_view::sv"><span class="n">sv</span></a></span> is not an lvalue reference, the resulting view will
<a class="reference internal" href="#mapped-basis-view-ref"><span class="std std-ref">hold a copy</span></a> of <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0ENK10libcommute12basis_mapper15make_const_viewE17mapped_basis_viewIK11StateVectorERR11StateVector" title="libcommute::basis_mapper::make_const_view::sv"><span class="n">sv</span></a></span>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>To reduce memory footprint, <a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> objects store
a reference to the basis index map owned by their parent
<a class="reference internal" href="#_CPPv4N10libcommute12basis_mapperE" title="libcommute::basis_mapper"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">basis_mapper</span></code></a> object. For this reason, the views should never
outlive the mapper.</p>
</div>
</dd></dl>

<p class="rubric">Other methods</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute12basis_mapper4sizeEv">
<span id="_CPPv3NK10libcommute12basis_mapper4sizeEv"></span><span id="_CPPv2NK10libcommute12basis_mapper4sizeEv"></span><span id="libcommute::basis_mapper::sizeC"></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">size</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute12basis_mapper4sizeEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Number of elements in the index map.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute12basis_mapper3mapEv">
<span id="_CPPv3NK10libcommute12basis_mapper3mapEv"></span><span id="_CPPv2NK10libcommute12basis_mapper3mapEv"></span><span id="libcommute::basis_mapper::mapC"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">unordered_map</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="sig-name descname"><span class="n"><span class="pre">map</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute12basis_mapper3mapEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Direct access to the underlying index map.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute12basis_mapper11inverse_mapEv">
<span id="_CPPv3NK10libcommute12basis_mapper11inverse_mapEv"></span><span id="_CPPv2NK10libcommute12basis_mapper11inverse_mapEv"></span><span id="libcommute::basis_mapper::inverse_mapC"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">unordered_map</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">inverse_map</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute12basis_mapper11inverse_mapEv" title="Permalink to this definition"></a><br /></dt>
<dd><p>Build and return an inverse index map. Depending on map’s size, building
the inverse can be an expensive operation. Calling this method on a
non-invertible map is undefined behavior.</p>
</dd></dl>

</dd></dl>

</section>
<section id="n-fermion-sector-views">
<span id="n-fermion-sector-view"></span><h2>N-fermion sector views<a class="headerlink" href="#n-fermion-sector-views" title="Permalink to this heading"></a></h2>
<p>There are two more specialized flavours of the basis mapping views called
<span class="math notranslate nohighlight">\(N\)</span>-fermion sector views and <span class="math notranslate nohighlight">\(N\)</span>-fermion multisector views. They
can come in handy when working with particle-number preserving models of
fermions. If the model is large, then generating and storing a basis state index
map for <a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> may become too expensive.</p>
<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE">
<span id="_CPPv3I0_bEN10libcommute21n_fermion_sector_viewE"></span><span id="_CPPv2I0_bEN10libcommute21n_fermion_sector_viewE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Ref</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">true</span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_sector_view</span></span></span><a class="headerlink" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/n_fermion_sector_view.hpp&gt;</em></p>
<p>View of a <a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view::StateVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StateVector</span></code></a> object that translates basis state indices from
a full <a class="reference internal" href="hilbert_space.html#hilbert-space"><span class="std std-ref">Hilbert space</span></a> to its subspace (sector) with a
fixed total occupation of fermionic degrees of freedom <span class="math notranslate nohighlight">\(N\)</span>. The full
Hilbert space does not have to be purely fermionic.</p>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">n_fermion_sector_view</span></code></a> is generally less performant than
<a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> in terms of the index translation speed. However,
its required storage space scales only as <span class="math notranslate nohighlight">\(O(M \min(N, M - N))\)</span>, where
<span class="math notranslate nohighlight">\(M\)</span> is the total number of the fermionic degrees of freedom. This
scaling law is much milder that the exponential growth of the sector size.</p>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view::StateVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StateVector</span></code></a> - type of the underlying state vector object. Defining a
read-only view (such that prohibits <span class="cpp-expr sig sig-inline cpp"><span class="n">update_add_element</span><span class="p">(</span><span class="p">)</span></span> operations)
requires using a <code class="docutils literal notranslate"><span class="pre">const</span></code>-qualified type here. For example, one can use
<code class="docutils literal notranslate"><span class="pre">StateVector</span> <span class="pre">=</span> <span class="pre">std::vector&lt;double&gt;</span></code> for a read-write view, and
<code class="docutils literal notranslate"><span class="pre">StateVector</span> <span class="pre">=</span> <span class="pre">const</span> <span class="pre">std::vector&lt;double&gt;</span></code> for a read-only view.</p>
<p id="n-fermion-sector-view-ref"><a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view::Ref"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">Ref</span></code></a> - by default, <a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">n_fermion_sector_view</span></code></a>
stores a reference to the underlying state vector. Setting this option to
<code class="docutils literal notranslate"><span class="pre">false</span></code> will result in a copy being created and stored instead. This feature
can be useful when the underlying type is already a view-like object similar
to <code class="docutils literal notranslate"><span class="pre">Eigen::Map</span></code>.</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej">
<span id="_CPPv3I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej"></span><span id="_CPPv2I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SV</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_sector_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej" title="libcommute::n_fermion_sector_view::n_fermion_sector_view::SV"><span class="n"><span class="pre">SV</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span>, <a class="reference internal" href="#_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej" title="libcommute::n_fermion_sector_view::n_fermion_sector_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej" title="Permalink to this definition"></a><br /></dt>
<dd><p>Construct a view of the state vector <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej" title="libcommute::n_fermion_sector_view::n_fermion_sector_view::sv"><span class="n">sv</span></a></span>, defined in the
<span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej" title="libcommute::n_fermion_sector_view::n_fermion_sector_view::N"><span class="n">N</span></a></span>-fermion sector of the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute21n_fermion_sector_view21n_fermion_sector_viewERR2SVRK6HSTypej" title="libcommute::n_fermion_sector_view::n_fermion_sector_view::hs"><span class="n">hs</span></a></span>.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute21n_fermion_sector_view9map_indexE13sv_index_type">
<span id="_CPPv3NK10libcommute21n_fermion_sector_view9map_indexE13sv_index_type"></span><span id="_CPPv2NK10libcommute21n_fermion_sector_view9map_indexE13sv_index_type"></span><span id="libcommute::n_fermion_sector_view::map_index__sv_index_typeC"></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">map_index</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">index</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute21n_fermion_sector_view9map_indexE13sv_index_type" title="Permalink to this definition"></a><br /></dt>
<dd><p>Translate a basis state <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4NK10libcommute21n_fermion_sector_view9map_indexE13sv_index_type" title="libcommute::n_fermion_sector_view::map_index::index"><span class="n">index</span></a></span> from the full Hilbert space to the
sector.</p>
</dd></dl>

</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute17sector_descriptorE">
<span id="_CPPv3I0EN10libcommute17sector_descriptorE"></span><span id="_CPPv2I0EN10libcommute17sector_descriptorE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">sector_descriptor</span></span></span><a class="headerlink" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Description of an <span class="math notranslate nohighlight">\(N\)</span>-fermion sector defined over a subset of fermionic
degrees of freedom.</p>
<p><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor::HSType"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">HSType</span></code></a> - type of the full Hilbert space this sector belongs to.</p>
<dl class="cpp member">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute17sector_descriptor7indicesE">
<span id="_CPPv3N10libcommute17sector_descriptor7indicesE"></span><span id="_CPPv2N10libcommute17sector_descriptor7indicesE"></span><span id="libcommute::sector_descriptor::indices__std::set:HSType::index_types:"></span><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">set</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">index_types</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">indices</span></span></span><a class="headerlink" href="#_CPPv4N10libcommute17sector_descriptor7indicesE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Set of indices corresponding to the relevant fermionic degrees of freedom.</p>
</dd></dl>

<dl class="cpp member">
<dt class="sig sig-object cpp" id="_CPPv4N10libcommute17sector_descriptor1NE">
<span id="_CPPv3N10libcommute17sector_descriptor1NE"></span><span id="_CPPv2N10libcommute17sector_descriptor1NE"></span><span id="libcommute::sector_descriptor::N__unsigned-i"></span><span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">N</span></span></span><a class="headerlink" href="#_CPPv4N10libcommute17sector_descriptor1NE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Total occupation of the sector.</p>
</dd></dl>

</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE">
<span id="_CPPv3I0_bEN10libcommute26n_fermion_multisector_viewE"></span><span id="_CPPv2I0_bEN10libcommute26n_fermion_multisector_viewE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="kt"><span class="pre">bool</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">Ref</span></span></span><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="k"><span class="pre">true</span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_multisector_view</span></span></span><a class="headerlink" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="Permalink to this definition"></a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/n_fermion_sector_view.hpp&gt;</em></p>
<p>View of a <a class="reference internal" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="libcommute::n_fermion_multisector_view::StateVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StateVector</span></code></a> object that translates basis state indices from
a full <a class="reference internal" href="hilbert_space.html#hilbert-space"><span class="std std-ref">Hilbert space</span></a> to an <span class="math notranslate nohighlight">\(N\)</span>-fermion
multisector. A multisector is a set of all basis states, which have
<span class="math notranslate nohighlight">\(N_1\)</span> particles within a subset of fermionic modes <span class="math notranslate nohighlight">\(\{S_1\}\)</span>,
<span class="math notranslate nohighlight">\(N_2\)</span> particles within another subset <span class="math notranslate nohighlight">\(\{S_2\}\)</span> and so on. There
can be any number of individual pairs <span class="math notranslate nohighlight">\((\{S_i\}, N_i)\)</span> (sectors
contributing to the multisector) as long as all subsets <span class="math notranslate nohighlight">\(\{S_i\}\)</span> are
disjoint. The full Hilbert space does not have to be purely fermionic.</p>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="libcommute::n_fermion_multisector_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">n_fermion_multisector_view</span></code></a> is generally less performant than
<a class="reference internal" href="#_CPPv4I0_bEN10libcommute17mapped_basis_viewE" title="libcommute::mapped_basis_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">mapped_basis_view</span></code></a> in terms of the index translation speed. However,
its required storage space scales only as
<span class="math notranslate nohighlight">\(O(\sum_i M_i \min(N_i, M_i - N_i))\)</span>, where
<span class="math notranslate nohighlight">\(M_i = |\{S_i\}|\)</span>. This scaling law is much milder that the exponential
growth of the multisector size.</p>
<p>It is advised to use <a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">n_fermion_sector_view</span></code></a> instead, if there is only
one contributing sector that also spans all fermionic degrees of freedom.</p>
<p><a class="reference internal" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="libcommute::n_fermion_multisector_view::StateVector"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">StateVector</span></code></a> - type of the underlying state vector object. Defining a
read-only view (such that prohibits <span class="cpp-expr sig sig-inline cpp"><span class="n">update_add_element</span><span class="p">(</span><span class="p">)</span></span> operations)
requires using a <code class="docutils literal notranslate"><span class="pre">const</span></code>-qualified type here. For example, one can use
<code class="docutils literal notranslate"><span class="pre">StateVector</span> <span class="pre">=</span> <span class="pre">std::vector&lt;double&gt;</span></code> for a read-write view, and
<code class="docutils literal notranslate"><span class="pre">StateVector</span> <span class="pre">=</span> <span class="pre">const</span> <span class="pre">std::vector&lt;double&gt;</span></code> for a read-only view.</p>
<p id="n-fermion-multisector-view-ref"><a class="reference internal" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="libcommute::n_fermion_multisector_view::Ref"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">Ref</span></code></a> - by default, <a class="reference internal" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="libcommute::n_fermion_multisector_view"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">n_fermion_multisector_view</span></code></a>
stores a reference to the underlying state vector. Setting this option to
<code class="docutils literal notranslate"><span class="pre">false</span></code> will result in a copy being created and stored instead. This feature
can be useful when the underlying type is already a view-like object similar
to <code class="docutils literal notranslate"><span class="pre">Eigen::Map</span></code>.</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE">
<span id="_CPPv3I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span id="_CPPv2I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">SV</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_multisector_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_view::n_fermion_multisector_view::SV"><span class="n"><span class="pre">SV</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span>, <a class="reference internal" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_view::n_fermion_multisector_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor"><span class="n"><span class="pre">sector_descriptor</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_view::n_fermion_multisector_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Construct a view of the state vector <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_view::n_fermion_multisector_view::sv"><span class="n">sv</span></a></span>, defined in the
<span class="math notranslate nohighlight">\(N\)</span>-fermion multisector of the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_view::n_fermion_multisector_view::hs"><span class="n">hs</span></a></span>.
The multisector is defined via a list of contributing <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute26n_fermion_multisector_view26n_fermion_multisector_viewERR2SVRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_view::n_fermion_multisector_view::sectors"><span class="n">sectors</span></a></span>
(list of <span class="math notranslate nohighlight">\((\{S_i\}, N_i)\)</span> pairs).</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4NK10libcommute26n_fermion_multisector_view9map_indexE13sv_index_type">
<span id="_CPPv3NK10libcommute26n_fermion_multisector_view9map_indexE13sv_index_type"></span><span id="_CPPv2NK10libcommute26n_fermion_multisector_view9map_indexE13sv_index_type"></span><span id="libcommute::n_fermion_multisector_view::map_index__sv_index_typeC"></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">map_index</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">index</span></span><span class="sig-paren">)</span><span class="w"> </span><span class="k"><span class="pre">const</span></span><a class="headerlink" href="#_CPPv4NK10libcommute26n_fermion_multisector_view9map_indexE13sv_index_type" title="Permalink to this definition"></a><br /></dt>
<dd><p>Translate a basis state <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4NK10libcommute26n_fermion_multisector_view9map_indexE13sv_index_type" title="libcommute::n_fermion_multisector_view::map_index::index"><span class="n">index</span></a></span> from the full Hilbert space to the
multisector.</p>
</dd></dl>

</dd></dl>

<p>Besides <a class="reference internal" href="#_CPPv4I0_bEN10libcommute21n_fermion_sector_viewE" title="libcommute::n_fermion_sector_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">n_fermion_sector_view</span></code></a> and <a class="reference internal" href="#_CPPv4I0_bEN10libcommute26n_fermion_multisector_viewE" title="libcommute::n_fermion_multisector_view"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">n_fermion_multisector_view</span></code></a>,
<em>&lt;libcommute/loperator/n_fermion_sector_view.hpp&gt;</em> defines a few supplemental
utility functions that help working with (multi)sectors.</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN10libcommute13make_nfs_viewEDaRR11StateVectorRK6HSTypej">
<span id="_CPPv3I00EN10libcommute13make_nfs_viewERR11StateVectorRK6HSTypej"></span><span id="_CPPv2I00EN10libcommute13make_nfs_viewERR11StateVectorRK6HSTypej"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">make_nfs_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN10libcommute13make_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_nfs_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span>, <a class="reference internal" href="#_CPPv4I00EN10libcommute13make_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_nfs_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute13make_nfs_viewEDaRR11StateVectorRK6HSTypej" title="Permalink to this definition"></a><br /></dt>
<dt class="sig sig-object cpp" id="_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej">
<span id="_CPPv3I00EN10libcommute19make_const_nfs_viewERR11StateVectorRK6HSTypej"></span><span id="_CPPv2I00EN10libcommute19make_const_nfs_viewERR11StateVectorRK6HSTypej"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">make_const_nfs_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span>, <a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="Permalink to this definition"></a><br /></dt>
<dd><p>Make and return a read/write or constant <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::N"><span class="n">N</span></a></span>-fermion sector view of
<span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::sv"><span class="n">sv</span></a></span> within the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::hs"><span class="n">hs</span></a></span>. If <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::sv"><span class="n">sv</span></a></span> is not an
lvalue reference, the resulting view will
<a class="reference internal" href="#n-fermion-sector-view-ref"><span class="std std-ref">hold a copy</span></a> of <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute19make_const_nfs_viewEDaRR11StateVectorRK6HSTypej" title="libcommute::make_const_nfs_view::sv"><span class="n">sv</span></a></span>.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I00EN10libcommute14make_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE">
<span id="_CPPv3I00EN10libcommute14make_nfms_viewERR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span id="_CPPv2I00EN10libcommute14make_nfms_viewERR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">make_nfms_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN10libcommute14make_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_nfms_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span>, <a class="reference internal" href="#_CPPv4I00EN10libcommute14make_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_nfms_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor"><span class="n"><span class="pre">sector_descriptor</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00EN10libcommute14make_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_nfms_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute14make_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="Permalink to this definition"></a><br /></dt>
<dt class="sig sig-object cpp" id="_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE">
<span id="_CPPv3I00EN10libcommute20make_const_nfms_viewERR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span id="_CPPv2I00EN10libcommute20make_const_nfms_viewERR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">StateVector</span></span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="kt"><span class="pre">auto</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">make_const_nfms_view</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::StateVector"><span class="n"><span class="pre">StateVector</span></span></a><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sv</span></span>, <a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor"><span class="n"><span class="pre">sector_descriptor</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Make and return a read/write or constant <span class="math notranslate nohighlight">\(N\)</span>-fermion multisector view of
<span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::sv"><span class="n">sv</span></a></span> within the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::hs"><span class="n">hs</span></a></span>. The multisector is
defined via a list of contributing <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::sectors"><span class="n">sectors</span></a></span> (list of
<span class="math notranslate nohighlight">\((\{S_i\}, N_i)\)</span> pairs). If <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::sv"><span class="n">sv</span></a></span> is not an lvalue reference,
the resulting view will
<a class="reference internal" href="#n-fermion-sector-view-ref"><span class="std std-ref">hold a copy</span></a> of <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I00EN10libcommute20make_const_nfms_viewEDaRR11StateVectorRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::make_const_nfms_view::sv"><span class="n">sv</span></a></span>.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute21n_fermion_sector_sizeE13sv_index_typeRK6HSTypej">
<span id="_CPPv3I0EN10libcommute21n_fermion_sector_sizeERK6HSTypej"></span><span id="_CPPv2I0EN10libcommute21n_fermion_sector_sizeERK6HSTypej"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_sector_size</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN10libcommute21n_fermion_sector_sizeE13sv_index_typeRK6HSTypej" title="libcommute::n_fermion_sector_size::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN10libcommute21n_fermion_sector_sizeE13sv_index_typeRK6HSTypej" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of the <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute21n_fermion_sector_sizeE13sv_index_typeRK6HSTypej" title="libcommute::n_fermion_sector_size::N"><span class="n">N</span></a></span>-fermion sector within the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute21n_fermion_sector_sizeE13sv_index_typeRK6HSTypej" title="libcommute::n_fermion_sector_size::hs"><span class="n">hs</span></a></span>.</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute26n_fermion_multisector_sizeE13sv_index_typeRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE">
<span id="_CPPv3I0EN10libcommute26n_fermion_multisector_sizeERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span id="_CPPv2I0EN10libcommute26n_fermion_multisector_sizeERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_multisector_size</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN10libcommute26n_fermion_multisector_sizeE13sv_index_typeRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_size::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor"><span class="n"><span class="pre">sector_descriptor</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute26n_fermion_multisector_sizeE13sv_index_typeRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_size::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN10libcommute26n_fermion_multisector_sizeE13sv_index_typeRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Size of the <span class="math notranslate nohighlight">\(N\)</span>-fermion multisector within the full Hilbert space
<span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute26n_fermion_multisector_sizeE13sv_index_typeRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_size::hs"><span class="n">hs</span></a></span>. The multisector is defined via a list of contributing
<span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute26n_fermion_multisector_sizeE13sv_index_typeRK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_size::sectors"><span class="n">sectors</span></a></span> (list of <span class="math notranslate nohighlight">\((\{S_i\}, N_i)\)</span> pairs).</p>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute29n_fermion_sector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypej">
<span id="_CPPv3I0EN10libcommute29n_fermion_sector_basis_statesERK6HSTypej"></span><span id="_CPPv2I0EN10libcommute29n_fermion_sector_basis_statesERK6HSTypej"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_sector_basis_states</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN10libcommute29n_fermion_sector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypej" title="libcommute::n_fermion_sector_basis_states::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN10libcommute29n_fermion_sector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypej" title="Permalink to this definition"></a><br /></dt>
<dd><p>Build and return a list of basis state indices forming the <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute29n_fermion_sector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypej" title="libcommute::n_fermion_sector_basis_states::N"><span class="n">N</span></a></span>-fermion
sector within the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute29n_fermion_sector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypej" title="libcommute::n_fermion_sector_basis_states::hs"><span class="n">hs</span></a></span>. The order of the indices in
the list is consistent with the results of
<a class="reference internal" href="#_CPPv4NK10libcommute21n_fermion_sector_view9map_indexE13sv_index_type" title="libcommute::n_fermion_sector_view::map_index"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">n_fermion_sector_view::map_index()</span></code></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">basis_states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_fermion_sector_basis_states</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_fermion_sector_view</span><span class="p">(</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">hs</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="n">sv_index_type</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">basis_states</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">view</span><span class="p">.</span><span class="n">map_index</span><span class="p">(</span><span class="n">basis_states</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="c1">// true for all n</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv4I0EN10libcommute34n_fermion_multisector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE">
<span id="_CPPv3I0EN10libcommute34n_fermion_multisector_basis_statesERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span id="_CPPv2I0EN10libcommute34n_fermion_multisector_basis_statesERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE"></span><span class="k"><span class="pre">template</span></span><span class="p"><span class="pre">&lt;</span></span><span class="k"><span class="pre">typename</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">HSType</span></span></span><span class="p"><span class="pre">&gt;</span></span><br /><span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><span class="n"><span class="pre">sv_index_type</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_fermion_multisector_basis_states</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4I0EN10libcommute34n_fermion_multisector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_basis_states::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">hs</span></span>, <span class="n"><span class="pre">std</span></span><span class="p"><span class="pre">::</span></span><span class="n"><span class="pre">vector</span></span><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute17sector_descriptorE" title="libcommute::sector_descriptor"><span class="n"><span class="pre">sector_descriptor</span></span></a><span class="p"><span class="pre">&lt;</span></span><a class="reference internal" href="#_CPPv4I0EN10libcommute34n_fermion_multisector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_basis_states::HSType"><span class="n"><span class="pre">HSType</span></span></a><span class="p"><span class="pre">&gt;</span></span><span class="p"><span class="pre">&gt;</span></span><span class="w"> </span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">&amp;</span></span><span class="n sig-param"><span class="pre">sectors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN10libcommute34n_fermion_multisector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="Permalink to this definition"></a><br /></dt>
<dd><p>Build and return a list of basis state indices forming an <span class="math notranslate nohighlight">\(N\)</span>-fermion
multisector within the full Hilbert space <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute34n_fermion_multisector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_basis_states::hs"><span class="n">hs</span></a></span>. The multisector is
defined via a list of contributing <span class="cpp-expr sig sig-inline cpp"><a class="reference internal" href="#_CPPv4I0EN10libcommute34n_fermion_multisector_basis_statesENSt6vectorI13sv_index_typeEERK6HSTypeRKNSt6vectorI17sector_descriptorI6HSTypeEEE" title="libcommute::n_fermion_multisector_basis_states::sectors"><span class="n">sectors</span></a></span> (list of
<span class="math notranslate nohighlight">\((\{S_i\}, N_i)\)</span> pairs). The order of the indices in the list is
consistent with the results of
<a class="reference internal" href="#_CPPv4NK10libcommute26n_fermion_multisector_view9map_indexE13sv_index_type" title="libcommute::n_fermion_multisector_view::map_index"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">n_fermion_multisector_view::map_index()</span></code></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">basis_states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_fermion_multisector_basis_states</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span><span class="w"> </span><span class="n">sectors</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n_fermion_multisector_view</span><span class="p">(</span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="n">hs</span><span class="p">,</span><span class="w"> </span><span class="n">sectors</span><span class="p">);</span>

<span class="k">for</span><span class="p">(</span><span class="n">sv_index_type</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">basis_states</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">view</span><span class="p">.</span><span class="n">map_index</span><span class="p">(</span><span class="n">basis_states</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="c1">// true for all n</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="monomial_action.html" class="btn btn-neutral float-left" title="Advanced: Linear operator representation of a user-defined algebra" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="space_partition.html" class="btn btn-neutral float-right" title="Finding invariant subspaces of a linear operator" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2022, Igor Krivenko.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>