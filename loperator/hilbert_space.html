

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Finite-dimensional Hilbert spaces &mdash; libcommute 0.5 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linear operators" href="loperator.html" />
    <link rel="prev" title="Introduction" href="intro.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> libcommute
          

          
            
            <img src="../_static/logo_small.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage.html">How to use <em>libcommute</em> in your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../expression/index.html">Domain-Specific Language for polynomial expressions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tools for exact diagonalization</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Finite-dimensional Hilbert spaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#elementary-spaces">Elementary spaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#advanced-customization-of-automatic-hilbert-space-construction">Advanced: Customization of automatic Hilbert space construction</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="loperator.html">Linear operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="monomial_action.html">Advanced: Linear operator representation of a user-defined algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="state_vector.html">State vectors</a></li>
<li class="toctree-l2"><a class="reference internal" href="space_partition.html">Finding invariant subspaces of a linear operator</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Advanced examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../search.html">Search</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">libcommute</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Tools for exact diagonalization</a> &raquo;</li>
        
      <li>Finite-dimensional Hilbert spaces</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/loperator/hilbert_space.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="finite-dimensional-hilbert-spaces">
<span id="hilbert-space"></span><h1>Finite-dimensional Hilbert spaces<a class="headerlink" href="#finite-dimensional-hilbert-spaces" title="Permalink to this headline">¶</a></h1>
<p>Class <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hilbert_space</span></code></a> is an abstraction of a finite-dimensional state
space of a quantum system. It contains information needed to construct a
<a class="reference internal" href="loperator.html#loperator"><span class="std std-ref">linear operator object</span></a> out of a
<a class="reference internal" href="../expression/expression.html#expression"><span class="std std-ref">polynomial expression</span></a>.</p>
<p>A <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hilbert_space</span></code></a> is defined as an (ordered) direct product of
<a class="reference internal" href="#elementary-spaces"><span class="std std-ref">elementary spaces</span></a> <span class="math notranslate nohighlight">\(\mathcal{H}_i\)</span>,</p>
<div class="math notranslate nohighlight">
\[\mathcal{H} = \mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \ldots \otimes
              \mathcal{H}_N.\]</div>
<p>An elementary space associated with an <a class="reference internal" href="../expression/generator.html#generator"><span class="std std-ref">algebra generator</span></a>
<span class="math notranslate nohighlight">\(g\)</span> is a vector space of dimension <span class="math notranslate nohighlight">\(2^b\)</span>, where <span class="math notranslate nohighlight">\(b\)</span> is
the smallest integer sufficient to construct a matrix representation of
<span class="math notranslate nohighlight">\(g\)</span>.
For instance, an elementary space associated with a fermionic
creation/annihilation operator is two-dimensional (<span class="math notranslate nohighlight">\(b = 1\)</span>); It is
spanned by the occupation number states <span class="math notranslate nohighlight">\(|0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle\)</span>.
For a spin-1 operator, we have a 4-dimensional elementary space.
There are three basis vectors <span class="math notranslate nohighlight">\(|m=0\rangle\)</span>, <span class="math notranslate nohighlight">\(|m=\pm 1\rangle\)</span> of
the irreducible representation, but one has to round the dimension up to the
nearest power of 2 (<span class="math notranslate nohighlight">\(b = 2\)</span>). Finally, in the case of a bosonic generator
one has to truncate the infinite-dimensional state space and manually set
<span class="math notranslate nohighlight">\(b\geq 1\)</span>.</p>
<p>The ordering of the elementary spaces in the product is established by the
algebra IDs of the generators <span class="math notranslate nohighlight">\(g\)</span> these spaces are associated with
(the smaller algebra ID comes first). Two elementary spaces sharing the same ID
are ordered according to the <a class="reference internal" href="#elementary-spaces"><span class="std std-ref">rules specific to the corresponding
algebra</span></a>.</p>
<p>The requirement of dimensions of the elementary spaces being powers of two is
not arbitrary. It is justified by the way basis states of the full space
<span class="math notranslate nohighlight">\(\mathcal{H}\)</span> are enumerated. Each basis state of <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> is
a direct product of basis vectors of the elementary spaces,</p>
<div class="math notranslate nohighlight">
\[|n\rangle_\mathcal{H} = |n_1\rangle_{\mathcal{H}_1} \otimes
                        |n_2\rangle_{\mathcal{H}_2} \otimes\ldots\otimes
                        |n_N\rangle_{\mathcal{H}_N}.\]</div>
<p>In the code, the basis vectors are represented by 64-bit unsigned integers
(<a class="reference internal" href="state_vector.html#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sv_index_type</span></code></a>).
The binary form of <span class="math notranslate nohighlight">\(|n\rangle_\mathcal{H}\)</span> is
then a concatenation of binary forms of <span class="math notranslate nohighlight">\(|n_i\rangle_{\mathcal{H}_i}\)</span>.
For example, the following picture shows memory representation of basis
state <span class="math notranslate nohighlight">\(|90\rangle_\mathcal{H} = |0\rangle_{\mathcal{H}_1} \otimes
|5\rangle_{\mathcal{H}_2} \otimes |1\rangle_{\mathcal{H}_3} \otimes
|1\rangle_{\mathcal{H}_4}\)</span>. Cells (bits) of the same color belong to the same
elementary space and the higher blank cells 7-63 are unused – set to zero.</p>
<a class="reference internal image-reference" href="../_images/basis_state.svg"><img alt="../_images/basis_state.svg" src="../_images/basis_state.svg" width="800" /></a>
<p>The simplest way to construct a <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hilbert_space</span></code></a> object is by calling
<a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> on an expression.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">libcommute</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">static_indices</span><span class="o">::</span><span class="n">real</span><span class="p">;</span> <span class="c1">// For n()</span>

<span class="k">auto</span> <span class="n">H</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">n</span><span class="p">(</span><span class="s">&quot;up&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">(</span><span class="s">&quot;dn&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Construct a 4-dimensional Hilbert space, which is a product of two</span>
<span class="c1">// fermionic elementary spaces (for {&quot;up&quot;, 0} and {&quot;dn&quot;, 0}).</span>
<span class="k">auto</span> <span class="n">hs</span> <span class="o">=</span> <span class="n">make_hilbert_space</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>
</pre></div>
</div>
<p><a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> is a convenience function that forwards its
arguments to one of <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hilbert_space</span></code></a>’s constructors. That constructor
iterates over all generators found in the expression and adds their associated
elementary spaces into the product <span class="math notranslate nohighlight">\(\mathcal{H}\)</span>. Sometimes, it may
require extra bits of information to translate a generator into an elementary
space. Perhaps the most prominent example here is a bosonic elementary space,
whose truncated dimension must be set by the user. It is possible to
<a class="reference internal" href="#es-constructor"><span class="std std-ref">customize the Hilbert space construction procedure</span></a>
by passing an extra argument to <a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a>. The following
code snippet shows how to set the truncated space dimension for all bosonic
generators at once.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">libcommute</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">static_indices</span><span class="o">::</span><span class="n">real</span><span class="p">;</span> <span class="c1">// For a_dag() and a()</span>

<span class="k">auto</span> <span class="n">H</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">a_dag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">a_dag</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">);</span>

<span class="c1">// hs is a direct product of two bosonic elementary spaces, each with</span>
<span class="c1">// dimension 2^4 = 16.</span>
<span class="k">auto</span> <span class="n">hs</span> <span class="o">=</span> <span class="n">make_hilbert_space</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">boson_es_constructor</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
</pre></div>
</div>
<p>Other, more refined ways to create a Hilbert space are (a) to explicitly provide
a list of elementary spaces or (b) to start from an empty product and add
elementary spaces one by one. One might have to resort to these approaches when
some elementary spaces must be added into the product, but their corresponding
generators are not necessarily found in <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="k">namespace</span> <span class="n">libcommute</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">static_indices</span><span class="p">;</span> <span class="c1">// For make_space_*()</span>

<span class="c1">// A product of three elementary spaces</span>
<span class="c1">// std::string and int are index types of generators</span>
<span class="n">hilbert_space</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">hs1</span><span class="p">(</span>
  <span class="n">make_space_fermion</span><span class="p">(</span><span class="s">&quot;dn&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>   <span class="c1">// Fermion</span>
  <span class="n">make_space_boson</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>   <span class="c1">// Boson truncated to dim = 2^4</span>
  <span class="n">make_space_spin</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1">// Spin-1/2</span>
<span class="p">);</span>

<span class="c1">// Empty space, to be filled later</span>
<span class="n">hilbert_space</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">hs2</span><span class="p">;</span>
<span class="c1">// Fill the space</span>
<span class="n">hs2</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">make_space_fermion</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>  <span class="c1">// Add a fermion</span>
<span class="n">hs2</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">make_space_boson</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// Add a boson</span>
</pre></div>
</div>
<p>The order in which the elementary spaces are passed to the constructor or added
does not matter – they will be reordered automatically.</p>
<dl class="cpp class">
<dt id="_CPPv4IDpEN10libcommute13hilbert_spaceE">
<span id="_CPPv3IDpEN10libcommute13hilbert_spaceE"></span><span id="_CPPv2IDpEN10libcommute13hilbert_spaceE"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">hilbert_space</code><a class="headerlink" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/hilbert_space.hpp&gt;</em></p>
<p>State space of a quantum system as a direct product of
<a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">elementary</span> <span class="pre">spaces</span></code></a>.</p>
<p>Parameter pack <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space::IndexTypes"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">IndexTypes</span></code></a> must agree with that of
<a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">elementary_space</span></code></a> and/or <a class="reference internal" href="../expression/expression.html#_CPPv4I0DpEN10libcommute10expressionE" title="libcommute::expression"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">libcommute::expression</span></code></a> objects,
which are used to construct this Hilbert space.</p>
<p class="rubric">Constructors</p>
<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_space10expressionEv">
<span id="_CPPv3N10libcommute13hilbert_space10expressionEv"></span><span id="_CPPv2N10libcommute13hilbert_space10expressionEv"></span><span id="libcommute::hilbert_space::expression"></span><code class="sig-name descname">expression</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space10expressionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty space.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute13hilbert_space13hilbert_spaceEDpRR4Args">
<span id="_CPPv3IDpEN10libcommute13hilbert_space13hilbert_spaceEDpRR4Args"></span><span id="_CPPv2IDpEN10libcommute13hilbert_space13hilbert_spaceEDpRR4Args"></span>template&lt;typename ...<code class="sig-name descname">Args</code>&gt;<br /><em class="property">explicit</em> <code class="sig-name descname">hilbert_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_space13hilbert_spaceEDpRR4Args" title="libcommute::hilbert_space::hilbert_space::Args">Args</a>&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute13hilbert_space13hilbert_spaceEDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct from a list of elementary spaces. The elementary spaces need not
be given in any particular order.
Throws <a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space21hilbert_space_too_bigE" title="libcommute::hilbert_space::hilbert_space_too_big"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">hilbert_space_too_big</span></code></a> if all elementary spaces together
would overflow the 64-bit integer type of the basis state index.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor">
<span id="_CPPv3I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor"></span><span id="_CPPv2I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor"></span>template&lt;typename <code class="sig-name descname">ScalarType</code>, typename <code class="sig-name descname">ESConstructor</code> = <a class="reference internal" href="#_CPPv4N10libcommute22default_es_constructorE" title="libcommute::default_es_constructor">default_es_constructor</a>&gt;<br /><code class="sig-name descname">hilbert_space</code><span class="sig-paren">(</span>libcommute::<a class="reference internal" href="../expression/expression.html#_CPPv4I0DpEN10libcommute10expressionE" title="libcommute::expression">expression</a>&lt;<a class="reference internal" href="#_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor" title="libcommute::hilbert_space::hilbert_space::ScalarType">ScalarType</a>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space::IndexTypes">IndexTypes</a>...&gt; <em class="property">const</em> &amp;<em>expr</em>, <a class="reference internal" href="#_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor" title="libcommute::hilbert_space::hilbert_space::ESConstructor">ESConstructor</a> &amp;&amp;<em>es_constr</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Inspect an expression <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor" title="libcommute::hilbert_space::hilbert_space::expr"><span class="pre">expr</span></a></code> and collect all elementary spaces
associated with algebra generators found in <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor" title="libcommute::hilbert_space::hilbert_space::expr"><span class="pre">expr</span></a></code>.
Construction of the elementary spaces is performed by the functor
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I00EN10libcommute13hilbert_space13hilbert_spaceERKN10libcommute10expressionI10ScalarTypeDp10IndexTypesEERR13ESConstructor" title="libcommute::hilbert_space::hilbert_space::es_constr"><span class="pre">es_constr</span></a></code>.
Throws <a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space21hilbert_space_too_bigE" title="libcommute::hilbert_space::hilbert_space_too_big"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">hilbert_space_too_big</span></code></a> if all collected elementary spaces
together would overflow the 64-bit integer type of the basis state index.</p>
</dd></dl>

<p class="rubric">Copy/move-constructors and assignments</p>
<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_space13hilbert_spaceERK13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_space13hilbert_spaceERK13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_space13hilbert_spaceERK13hilbert_space"></span><span id="libcommute::hilbert_space::hilbert_space__hilbert_spaceCR"></span><code class="sig-name descname">hilbert_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space13hilbert_spaceERK13hilbert_space" title="libcommute::hilbert_space::hilbert_space">hilbert_space</a> <em class="property">const</em>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space13hilbert_spaceERK13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_space13hilbert_spaceERR13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_space13hilbert_spaceERR13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_space13hilbert_spaceERR13hilbert_space"></span><span id="libcommute::hilbert_space::hilbert_space__hilbert_spaceRR"></span><code class="sig-name descname">hilbert_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space13hilbert_spaceERR13hilbert_space" title="libcommute::hilbert_space::hilbert_space">hilbert_space</a>&amp;&amp;<span class="sig-paren">)</span> <em class="property">noexcept</em> = default<a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space13hilbert_spaceERR13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_spaceaSERK13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_spaceaSERK13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_spaceaSERK13hilbert_space"></span><span id="libcommute::hilbert_space::assign-operator__hilbert_spaceCR"></span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> &amp;<code class="sig-name descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_spaceaSERK13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_spaceaSERR13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_spaceaSERR13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_spaceaSERR13hilbert_space"></span><span id="libcommute::hilbert_space::assign-operator__hilbert_spaceRR"></span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> &amp;<code class="sig-name descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a>&amp;&amp;<span class="sig-paren">)</span> <em class="property">noexcept</em> = default<a class="headerlink" href="#_CPPv4N10libcommute13hilbert_spaceaSERR13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p class="rubric">Other methods and friend functions</p>
<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_spaceeqERK13hilbert_spaceRK13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_spaceeqERK13hilbert_spaceRK13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_spaceeqERK13hilbert_spaceRK13hilbert_space"></span><span id="libcommute::hilbert_space::eq-operator__hilbert_spaceCR.hilbert_spaceCR"></span><em class="property">friend</em> bool <code class="sig-name descname">operator==</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em> &amp;<em>hs1</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em> &amp;<em>hs2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_spaceeqERK13hilbert_spaceRK13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute13hilbert_spaceneERK13hilbert_spaceRK13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_spaceneERK13hilbert_spaceRK13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_spaceneERK13hilbert_spaceRK13hilbert_space"></span><span id="libcommute::hilbert_space::neq-operator__hilbert_spaceCR.hilbert_spaceCR"></span><em class="property">friend</em> bool <code class="sig-name descname">operator!=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em> &amp;<em>hs1</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em> &amp;<em>hs2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_spaceneERK13hilbert_spaceRK13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check that two Hilbert spaces have an identical/different structure.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_space3addERK16elementary_spaceIDp10IndexTypesE">
<span id="_CPPv3N10libcommute13hilbert_space3addERK16elementary_spaceIDp10IndexTypesE"></span><span id="_CPPv2N10libcommute13hilbert_space3addERK16elementary_spaceIDp10IndexTypesE"></span><span id="libcommute::hilbert_space::add__elementary_space:IndexTypesDp:CR"></span>void <code class="sig-name descname">add</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space::IndexTypes">IndexTypes</a>...&gt; <em class="property">const</em> &amp;<em>es</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space3addERK16elementary_spaceIDp10IndexTypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert a new elementary space into the product. Throws
<a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space23elementary_space_existsE" title="libcommute::hilbert_space::elementary_space_exists"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">elementary_space_exists</span></code></a> if an elementary space equivalent to
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space3addERK16elementary_spaceIDp10IndexTypesE" title="libcommute::hilbert_space::add::es"><span class="pre">es</span></a></code> is already part of the product.
Throws <a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space21hilbert_space_too_bigE" title="libcommute::hilbert_space::hilbert_space_too_big"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">hilbert_space_too_big</span></code></a> if adding <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space3addERK16elementary_spaceIDp10IndexTypesE" title="libcommute::hilbert_space::add::es"><span class="pre">es</span></a></code> into the product
would overflow the 64-bit integer type of the basis state index.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute13hilbert_space3hasERK16elementary_spaceIDp10IndexTypesE">
<span id="_CPPv3NK10libcommute13hilbert_space3hasERK16elementary_spaceIDp10IndexTypesE"></span><span id="_CPPv2NK10libcommute13hilbert_space3hasERK16elementary_spaceIDp10IndexTypesE"></span><span id="libcommute::hilbert_space::has__elementary_space:IndexTypesDp:CRC"></span>bool <code class="sig-name descname">has</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space::IndexTypes">IndexTypes</a>...&gt; <em class="property">const</em> &amp;<em>es</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute13hilbert_space3hasERK16elementary_spaceIDp10IndexTypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Is elementary space <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NK10libcommute13hilbert_space3hasERK16elementary_spaceIDp10IndexTypesE" title="libcommute::hilbert_space::has::es"><span class="pre">es</span></a></code> part of the product?</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute13hilbert_space9bit_rangeERK16elementary_spaceIDp10IndexTypesE">
<span id="_CPPv3NK10libcommute13hilbert_space9bit_rangeERK16elementary_spaceIDp10IndexTypesE"></span><span id="_CPPv2NK10libcommute13hilbert_space9bit_rangeERK16elementary_spaceIDp10IndexTypesE"></span><span id="libcommute::hilbert_space::bit_range__elementary_space:IndexTypesDp:CRC"></span>std::pair&lt;int, int&gt; <code class="sig-name descname">bit_range</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space::IndexTypes">IndexTypes</a>...&gt; <em class="property">const</em> &amp;<em>es</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute13hilbert_space9bit_rangeERK16elementary_spaceIDp10IndexTypesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the range of bits in the binary representation of a
basis state index that is occupied by the elementary space <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NK10libcommute13hilbert_space9bit_rangeERK16elementary_spaceIDp10IndexTypesE" title="libcommute::hilbert_space::bit_range::es"><span class="pre">es</span></a></code>.
The range is returned as a pair (first_bit, last_bit).
Throws <a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space26elementary_space_not_foundE" title="libcommute::hilbert_space::elementary_space_not_found"><code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">elementary_space_not_found</span></code></a> if <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NK10libcommute13hilbert_space9bit_rangeERK16elementary_spaceIDp10IndexTypesE" title="libcommute::hilbert_space::bit_range::es"><span class="pre">es</span></a></code> is not part of
the product.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute13hilbert_space17algebra_bit_rangeEi">
<span id="_CPPv3NK10libcommute13hilbert_space17algebra_bit_rangeEi"></span><span id="_CPPv2NK10libcommute13hilbert_space17algebra_bit_rangeEi"></span><span id="libcommute::hilbert_space::algebra_bit_range__iC"></span>std::pair&lt;int, int&gt; <em class="property">const</em> &amp;<code class="sig-name descname">algebra_bit_range</code><span class="sig-paren">(</span>int <em>algebra_id</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute13hilbert_space17algebra_bit_rangeEi" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the range of bits in the binary representation of a basis state
index that is occupied by all elementary spaces with a given
<a class="reference internal" href="../expression/generator.html#generator"><span class="std std-ref">algebra ID</span></a>. The range is always contiguous because
elementary spaces with the same algebra ID are grouped together in the
product. Throws <code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">std::runtime_error</span></code> if there is no elementary spaces
with the given ID in the product.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute13hilbert_space4sizeEv">
<span id="_CPPv3NK10libcommute13hilbert_space4sizeEv"></span><span id="_CPPv2NK10libcommute13hilbert_space4sizeEv"></span><span id="libcommute::hilbert_space::sizeC"></span>size_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute13hilbert_space4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of elementary spaces in the product.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute13hilbert_space12total_n_bitsEv">
<span id="_CPPv3NK10libcommute13hilbert_space12total_n_bitsEv"></span><span id="_CPPv2NK10libcommute13hilbert_space12total_n_bitsEv"></span><span id="libcommute::hilbert_space::total_n_bitsC"></span>int <code class="sig-name descname">total_n_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute13hilbert_space12total_n_bitsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The total number of used bits in the binary representation of a basis state
index.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute13hilbert_space3dimEv">
<span id="_CPPv3NK10libcommute13hilbert_space3dimEv"></span><span id="_CPPv2NK10libcommute13hilbert_space3dimEv"></span><span id="libcommute::hilbert_space::dimC"></span>size_t <code class="sig-name descname">dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute13hilbert_space3dimEv" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute13hilbert_space7get_dimERK13hilbert_space">
<span id="_CPPv3N10libcommute13hilbert_space7get_dimERK13hilbert_space"></span><span id="_CPPv2N10libcommute13hilbert_space7get_dimERK13hilbert_space"></span><span id="libcommute::hilbert_space::get_dim__hilbert_spaceCR"></span><em class="property">friend</em> size_t <code class="sig-name descname">get_dim</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em> &amp;<em>hs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space7get_dimERK13hilbert_space" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The dimension of this Hilbert space computed as a product of dimensions
of the elementary spaces.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0EN10libcommute13hilbert_space7foreachEvRK13hilbert_spaceRR7Functor">
<span id="_CPPv3I0EN10libcommute13hilbert_space7foreachERK13hilbert_spaceRR7Functor"></span><span id="_CPPv2I0EN10libcommute13hilbert_space7foreachERK13hilbert_spaceRR7Functor"></span>template&lt;typename <code class="sig-name descname">Functor</code>&gt;<br /><em class="property">friend</em> void <code class="sig-name descname">foreach</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a> <em class="property">const</em> &amp;<em>hs</em>, <a class="reference internal" href="#_CPPv4I0EN10libcommute13hilbert_space7foreachEvRK13hilbert_spaceRR7Functor" title="libcommute::hilbert_space::foreach::Functor">Functor</a> &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0EN10libcommute13hilbert_space7foreachEvRK13hilbert_spaceRR7Functor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Apply functor <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I0EN10libcommute13hilbert_space7foreachEvRK13hilbert_spaceRR7Functor" title="libcommute::hilbert_space::foreach::f"><span class="pre">f</span></a></code> to all basis state indices in <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I0EN10libcommute13hilbert_space7foreachEvRK13hilbert_spaceRR7Functor" title="libcommute::hilbert_space::foreach::hs"><span class="pre">hs</span></a></code>.
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I0EN10libcommute13hilbert_space7foreachEvRK13hilbert_spaceRR7Functor" title="libcommute::hilbert_space::foreach::f"><span class="pre">f</span></a></code> must accept one argument of type <a class="reference internal" href="state_vector.html#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">sv_index_type</span></code></a>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute13hilbert_space17basis_state_indexERK16elementary_spaceIDp10IndexTypesE13sv_index_type">
<span id="_CPPv3N10libcommute13hilbert_space17basis_state_indexERK16elementary_spaceIDp10IndexTypesE13sv_index_type"></span><span id="_CPPv2N10libcommute13hilbert_space17basis_state_indexERK16elementary_spaceIDp10IndexTypesE13sv_index_type"></span><span id="libcommute::hilbert_space::basis_state_index__elementary_space:IndexTypesDp:CR.sv_index_type"></span><a class="reference internal" href="state_vector.html#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type">sv_index_type</a> <code class="sig-name descname">basis_state_index</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space::IndexTypes">IndexTypes</a>...&gt; <em class="property">const</em> &amp;<em>es</em>, <a class="reference internal" href="state_vector.html#_CPPv4N10libcommute13sv_index_typeE" title="libcommute::sv_index_type">sv_index_type</a> <em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space17basis_state_indexERK16elementary_spaceIDp10IndexTypesE13sv_index_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Given an elementary space <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space17basis_state_indexERK16elementary_spaceIDp10IndexTypesE13sv_index_type" title="libcommute::hilbert_space::basis_state_index::es"><span class="pre">es</span></a></code> and an index <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute13hilbert_space17basis_state_indexERK16elementary_spaceIDp10IndexTypesE13sv_index_type" title="libcommute::hilbert_space::basis_state_index::n"><span class="pre">n</span></a></code> of a basis state
within it, return the corresponding basis state index within the full
Hilbert space.</p>
</dd></dl>

<p class="rubric">Exception types</p>
<dl class="cpp struct">
<dt id="_CPPv4N10libcommute13hilbert_space23elementary_space_existsE">
<span id="_CPPv3N10libcommute13hilbert_space23elementary_space_existsE"></span><span id="_CPPv2N10libcommute13hilbert_space23elementary_space_existsE"></span><span id="libcommute::hilbert_space::elementary_space_exists"></span><em class="property">struct </em><code class="sig-name descname">elementary_space_exists</code> : <em class="property">public</em> std::runtime_error<a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space23elementary_space_existsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Thrown when one tries to add an elementary space that is already part of
the product.</p>
</dd></dl>

<dl class="cpp struct">
<dt id="_CPPv4N10libcommute13hilbert_space26elementary_space_not_foundE">
<span id="_CPPv3N10libcommute13hilbert_space26elementary_space_not_foundE"></span><span id="_CPPv2N10libcommute13hilbert_space26elementary_space_not_foundE"></span><span id="libcommute::hilbert_space::elementary_space_not_found"></span><em class="property">struct </em><code class="sig-name descname">elementary_space_not_found</code> : <em class="property">public</em> std::runtime_error<a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space26elementary_space_not_foundE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Given elementary space is not part of the product.</p>
</dd></dl>

<dl class="cpp struct">
<dt id="_CPPv4N10libcommute13hilbert_space21hilbert_space_too_bigE">
<span id="_CPPv3N10libcommute13hilbert_space21hilbert_space_too_bigE"></span><span id="_CPPv2N10libcommute13hilbert_space21hilbert_space_too_bigE"></span><span id="libcommute::hilbert_space::hilbert_space_too_big"></span><em class="property">struct </em><code class="sig-name descname">hilbert_space_too_big</code> : <em class="property">public</em> std::runtime_error<a class="headerlink" href="#_CPPv4N10libcommute13hilbert_space21hilbert_space_too_bigE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The total basis state index size exceeds 64 bits.</p>
</dd></dl>

</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor">
<span id="_CPPv3I0Dp0EN10libcommute18make_hilbert_spaceERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor"></span><span id="_CPPv2I0Dp0EN10libcommute18make_hilbert_spaceERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor"></span>template&lt;typename <code class="sig-name descname">ScalarType</code>, typename ...<code class="sig-name descname">IndexTypes</code>, typename <code class="sig-name descname">ESConstructor</code> = <a class="reference internal" href="#_CPPv4N10libcommute22default_es_constructorE" title="libcommute::default_es_constructor">default_es_constructor</a>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space">hilbert_space</a>&lt;<a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space::IndexTypes">IndexTypes</a>...&gt; <code class="sig-name descname">make_hilbert_space</code><span class="sig-paren">(</span><a class="reference internal" href="../expression/expression.html#_CPPv4I0DpEN10libcommute10expressionE" title="libcommute::expression">expression</a>&lt;<a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space::ScalarType">ScalarType</a>, <a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space::IndexTypes">IndexTypes</a>...&gt; <em class="property">const</em> &amp;<em>expr</em>, <a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space::ESConstructor">ESConstructor</a> &amp;&amp;<em>es_constr</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/hilbert_space.hpp&gt;</em></p>
<p>A helper factory function that constructs an <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hilbert_space</span></code></a> instance
from an expression <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space::expr"><span class="pre">expr</span></a></code> using an
<a class="reference internal" href="#es-constructor"><span class="std std-ref">elementary space constructor</span></a>. This function is a
more convenient equivalent of one of <a class="reference internal" href="#_CPPv4IDpEN10libcommute13hilbert_spaceE" title="libcommute::hilbert_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">hilbert_space</span></code></a>’s constructors.</p>
</dd></dl>

<div class="section" id="elementary-spaces">
<span id="id1"></span><h2>Elementary spaces<a class="headerlink" href="#elementary-spaces" title="Permalink to this headline">¶</a></h2>
<p>An elementary space has an <a class="reference internal" href="../expression/generator.html#generator"><span class="std std-ref">algebra ID</span></a> assigned to it and
carries a tuple of indices. Together, these two pieces of information link
the elementary space to algebra generators acting in it.</p>
<dl class="cpp class">
<dt id="_CPPv4IDpEN10libcommute16elementary_spaceE">
<span id="_CPPv3IDpEN10libcommute16elementary_spaceE"></span><span id="_CPPv2IDpEN10libcommute16elementary_spaceE"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">elementary_space</code><a class="headerlink" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space.hpp&gt;</em></p>
<p>Abstract base class for elementary spaces. <a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space::IndexTypes"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">IndexTypes</span></code></a> are index types
of the associated algebra generators.</p>
<dl class="cpp type">
<dt id="_CPPv4N10libcommute16elementary_space11index_typesE">
<span id="_CPPv3N10libcommute16elementary_space11index_typesE"></span><span id="_CPPv2N10libcommute16elementary_space11index_typesE"></span><em class="property">using </em><code class="sig-name descname">index_types</code> = std::tuple&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space::IndexTypes">IndexTypes</a>...&gt;<a class="headerlink" href="#_CPPv4N10libcommute16elementary_space11index_typesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Index tuple type.</p>
</dd></dl>

<p class="rubric">Constructors</p>
<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_space16elementary_spaceEDpRK10IndexTypes">
<span id="_CPPv3N10libcommute16elementary_space16elementary_spaceEDpRK10IndexTypes"></span><span id="_CPPv2N10libcommute16elementary_space16elementary_spaceEDpRK10IndexTypes"></span><span id="libcommute::elementary_space::elementary_space__IndexTypesCRDp"></span><code class="sig-name descname">elementary_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space::IndexTypes">IndexTypes</a> <em class="property">const</em>&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceEDpRK10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute16elementary_space16elementary_spaceERK11index_types">
<span id="_CPPv3N10libcommute16elementary_space16elementary_spaceERK11index_types"></span><span id="_CPPv2N10libcommute16elementary_space16elementary_spaceERK11index_types"></span><span id="libcommute::elementary_space::elementary_space__index_typesCR"></span><code class="sig-name descname">elementary_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_space11index_typesE" title="libcommute::elementary_space::index_types">index_types</a> <em class="property">const</em> &amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceERK11index_types" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute16elementary_space16elementary_spaceERR11index_types">
<span id="_CPPv3N10libcommute16elementary_space16elementary_spaceERR11index_types"></span><span id="_CPPv2N10libcommute16elementary_space16elementary_spaceERR11index_types"></span><span id="libcommute::elementary_space::elementary_space__index_typesRR"></span><code class="sig-name descname">elementary_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_space11index_typesE" title="libcommute::elementary_space::index_types">index_types</a> &amp;&amp;<em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceERR11index_types" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct from a list/tuple of indices.</p>
</dd></dl>

<p class="rubric">Copy/move-constructors, assignments and destructor</p>
<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_space16elementary_spaceERK16elementary_space">
<span id="_CPPv3N10libcommute16elementary_space16elementary_spaceERK16elementary_space"></span><span id="_CPPv2N10libcommute16elementary_space16elementary_spaceERK16elementary_space"></span><span id="libcommute::elementary_space::elementary_space__elementary_spaceCR"></span><code class="sig-name descname">elementary_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceERK16elementary_space" title="libcommute::elementary_space::elementary_space">elementary_space</a> <em class="property">const</em>&amp;<span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceERK16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_space16elementary_spaceERR16elementary_space">
<span id="_CPPv3N10libcommute16elementary_space16elementary_spaceERR16elementary_space"></span><span id="_CPPv2N10libcommute16elementary_space16elementary_spaceERR16elementary_space"></span><span id="libcommute::elementary_space::elementary_space__elementary_spaceRR"></span><code class="sig-name descname">elementary_space</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceERR16elementary_space" title="libcommute::elementary_space::elementary_space">elementary_space</a>&amp;&amp;<span class="sig-paren">)</span> <em class="property">noexcept</em> = default<a class="headerlink" href="#_CPPv4N10libcommute16elementary_space16elementary_spaceERR16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_spaceaSERK16elementary_space">
<span id="_CPPv3N10libcommute16elementary_spaceaSERK16elementary_space"></span><span id="_CPPv2N10libcommute16elementary_spaceaSERK16elementary_space"></span><span id="libcommute::elementary_space::assign-operator__elementary_spaceCR"></span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a> &amp;<code class="sig-name descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a> <em class="property">const</em>&amp;<span class="sig-paren">)</span> = default<a class="headerlink" href="#_CPPv4N10libcommute16elementary_spaceaSERK16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_spaceaSERR16elementary_space">
<span id="_CPPv3N10libcommute16elementary_spaceaSERR16elementary_space"></span><span id="_CPPv2N10libcommute16elementary_spaceaSERR16elementary_space"></span><span id="libcommute::elementary_space::assign-operator__elementary_spaceRR"></span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a> &amp;<code class="sig-name descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&amp;&amp;<span class="sig-paren">)</span> <em class="property">noexcept</em> = default<a class="headerlink" href="#_CPPv4N10libcommute16elementary_spaceaSERR16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_spaceD0Ev">
<span id="_CPPv3N10libcommute16elementary_spaceD0Ev"></span><span id="_CPPv2N10libcommute16elementary_spaceD0Ev"></span><span id="libcommute::elementary_space::~elementary_space"></span><em class="property">virtual</em> <code class="sig-name descname">~elementary_space</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_spaceD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="cpp function">
<dt id="_CPPv4NK10libcommute16elementary_space5cloneEv">
<span id="_CPPv3NK10libcommute16elementary_space5cloneEv"></span><span id="_CPPv2NK10libcommute16elementary_space5cloneEv"></span><span id="libcommute::elementary_space::cloneC"></span><em class="property">virtual</em> std::unique_ptr&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&gt; <code class="sig-name descname">clone</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space5cloneEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Virtual copy-constructor. Makes a copy of this elementary space managed by a
unique pointer.</p>
</dd></dl>

<p class="rubric">Algebra ID</p>
<dl class="cpp function">
<dt id="_CPPv4NK10libcommute16elementary_space10algebra_idEv">
<span id="_CPPv3NK10libcommute16elementary_space10algebra_idEv"></span><span id="_CPPv2NK10libcommute16elementary_space10algebra_idEv"></span><span id="libcommute::elementary_space::algebra_idC"></span><em class="property">virtual</em> int <code class="sig-name descname">algebra_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space10algebra_idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="../expression/generator.html#generator"><span class="std std-ref">Algebra ID</span></a> of the generators associated with this
elementary space.</p>
</dd></dl>

<p class="rubric">Index sequence</p>
<dl class="cpp function">
<dt id="_CPPv4NK10libcommute16elementary_space7indicesEv">
<span id="_CPPv3NK10libcommute16elementary_space7indicesEv"></span><span id="_CPPv2NK10libcommute16elementary_space7indicesEv"></span><span id="libcommute::elementary_space::indicesC"></span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_space11index_typesE" title="libcommute::elementary_space::index_types">index_types</a> <em class="property">const</em> &amp;<code class="sig-name descname">indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space7indicesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read-only access to the index tuple carried by this elementary space.</p>
</dd></dl>

<p class="rubric">Ordering within a direct product</p>
<dl class="cpp function">
<dt id="_CPPv4NK10libcommute16elementary_space5equalERK16elementary_space">
<span id="_CPPv3NK10libcommute16elementary_space5equalERK16elementary_space"></span><span id="_CPPv2NK10libcommute16elementary_space5equalERK16elementary_space"></span><span id="libcommute::elementary_space::equal__elementary_spaceCRC"></span><em class="property">protected </em><em class="property">virtual</em> bool <code class="sig-name descname">equal</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a> <em class="property">const</em> &amp;<em>es</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space5equalERK16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4NK10libcommute16elementary_space4lessERK16elementary_space">
<span id="_CPPv3NK10libcommute16elementary_space4lessERK16elementary_space"></span><span id="_CPPv2NK10libcommute16elementary_space4lessERK16elementary_space"></span><span id="libcommute::elementary_space::less__elementary_spaceCRC"></span><em class="property">protected </em><em class="property">virtual</em> bool <code class="sig-name descname">less</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a> <em class="property">const</em> &amp;<em>es</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space4lessERK16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4NK10libcommute16elementary_space7greaterERK16elementary_space">
<span id="_CPPv3NK10libcommute16elementary_space7greaterERK16elementary_space"></span><span id="_CPPv2NK10libcommute16elementary_space7greaterERK16elementary_space"></span><span id="libcommute::elementary_space::greater__elementary_spaceCRC"></span><em class="property">protected </em><em class="property">virtual</em> bool <code class="sig-name descname">greater</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a> <em class="property">const</em> &amp;<em>es</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space7greaterERK16elementary_space" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>These methods can be overridden by the derived classes to establish
the order of <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NK10libcommute16elementary_space7greaterERK16elementary_space" title="libcommute::elementary_space::greater::es"><span class="pre">es</span></a></code> w.r.t. <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">*</span><span class="pre">this</span></code> assuming both elementary spaces
are associated with the same algebra. The default implementation compares
index tuples of <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">*</span><span class="pre">this</span></code> and <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4NK10libcommute16elementary_space7greaterERK16elementary_space" title="libcommute::elementary_space::greater::es"><span class="pre">es</span></a></code>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4N10libcommute16elementary_spaceeqERK9generatorRK9generator">
<span id="_CPPv3N10libcommute16elementary_spaceeqERK9generatorRK9generator"></span><span id="_CPPv2N10libcommute16elementary_spaceeqERK9generatorRK9generator"></span><span id="libcommute::elementary_space::eq-operator__generatorCR.generatorCR"></span><em class="property">friend</em> bool <code class="sig-name descname">operator==</code><span class="sig-paren">(</span><a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es1</em>, <a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_spaceeqERK9generatorRK9generator" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute16elementary_spaceneERK9generatorRK9generator">
<span id="_CPPv3N10libcommute16elementary_spaceneERK9generatorRK9generator"></span><span id="_CPPv2N10libcommute16elementary_spaceneERK9generatorRK9generator"></span><span id="libcommute::elementary_space::neq-operator__generatorCR.generatorCR"></span><em class="property">friend</em> bool <code class="sig-name descname">operator!=</code><span class="sig-paren">(</span><a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es1</em>, <a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_spaceneERK9generatorRK9generator" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute16elementary_spaceltERK9generatorRK9generator">
<span id="_CPPv3N10libcommute16elementary_spaceltERK9generatorRK9generator"></span><span id="_CPPv2N10libcommute16elementary_spaceltERK9generatorRK9generator"></span><span id="libcommute::elementary_space::lt-operator__generatorCR.generatorCR"></span><em class="property">friend</em> bool <code class="sig-name descname">operator&lt;</code><span class="sig-paren">(</span><a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es1</em>, <a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_spaceltERK9generatorRK9generator" title="Permalink to this definition">¶</a><br /></dt>
<dt id="_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator">
<span id="_CPPv3N10libcommute16elementary_spacegtERK9generatorRK9generator"></span><span id="_CPPv2N10libcommute16elementary_spacegtERK9generatorRK9generator"></span><span id="libcommute::elementary_space::gt-operator__generatorCR.generatorCR"></span><em class="property">friend</em> bool <code class="sig-name descname">operator&gt;</code><span class="sig-paren">(</span><a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es1</em>, <a class="reference internal" href="../expression/generator.html#_CPPv4IDpEN10libcommute9generatorE" title="libcommute::generator">generator</a> <em class="property">const</em> &amp;<em>es2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Comparison operators for a pair of elementary spaces. First, they compare
algebra IDs of <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es1"><span class="pre">es1</span></a></code> and <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es2"><span class="pre">es2</span></a></code>. If those are equal,
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es1"><span class="pre">es1</span></a><span class="pre">.</span><span class="pre">equal</span><span class="pre">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es2"><span class="pre">es2</span></a><span class="pre">)</span></code>, <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es1"><span class="pre">es1</span></a><span class="pre">.</span><span class="pre">less</span><span class="pre">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es2"><span class="pre">es2</span></a><span class="pre">)</span></code> or <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es1"><span class="pre">es1</span></a><span class="pre">.</span><span class="pre">greater</span><span class="pre">(</span><a class="reference internal" href="#_CPPv4N10libcommute16elementary_spacegtERK9generatorRK9generator" title="libcommute::elementary_space::operator&gt;::es2"><span class="pre">es2</span></a><span class="pre">)</span></code>
is called.</p>
</dd></dl>

<p class="rubric">Binary representation of the basis state index</p>
<dl class="cpp function">
<dt id="_CPPv4NK10libcommute16elementary_space6n_bitsEv">
<span id="_CPPv3NK10libcommute16elementary_space6n_bitsEv"></span><span id="_CPPv2NK10libcommute16elementary_space6n_bitsEv"></span><span id="libcommute::elementary_space::n_bitsC"></span><em class="property">virtual</em> int <code class="sig-name descname">n_bits</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em> = 0<a class="headerlink" href="#_CPPv4NK10libcommute16elementary_space6n_bitsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>The number <span class="math notranslate nohighlight">\(b\)</span> of bits occupied by this elementary space (dimension of
the space is <span class="math notranslate nohighlight">\(2^b\)</span>).</p>
</dd></dl>

<p class="rubric">Predefined concrete elementary space types</p>
<dl class="cpp class">
<dt id="_CPPv4IDpEN10libcommute24elementary_space_fermionE">
<span id="_CPPv3IDpEN10libcommute24elementary_space_fermionE"></span><span id="_CPPv2IDpEN10libcommute24elementary_space_fermionE"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">elementary_space_fermion</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute24elementary_space_fermionE" title="libcommute::elementary_space_fermion::IndexTypes">IndexTypes</a>...&gt;<a class="headerlink" href="#_CPPv4IDpEN10libcommute24elementary_space_fermionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_fermion.hpp&gt;</em></p>
<p>An elementary space associated with fermionic algebra generators. This
elementary space is two-dimensional (<span class="math notranslate nohighlight">\(b = 1\)</span>).</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute10libcommute14static_indices18make_space_fermionE24elementary_space_fermionIDp10IndexTypesEDpRR10IndexTypes">
<span id="_CPPv3IDpEN10libcommute10libcommute14static_indices18make_space_fermionEDpRR10IndexTypes"></span><span id="_CPPv2IDpEN10libcommute10libcommute14static_indices18make_space_fermionEDpRR10IndexTypes"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute24elementary_space_fermionE" title="libcommute::elementary_space_fermion">elementary_space_fermion</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices18make_space_fermionE24elementary_space_fermionIDp10IndexTypesEDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_fermion::IndexTypes">IndexTypes</a>...&gt; <code class="sig-prename descclassname">libcommute::static_indices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">make_space_fermion</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices18make_space_fermionE24elementary_space_fermionIDp10IndexTypesEDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_fermion::IndexTypes">IndexTypes</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices18make_space_fermionE24elementary_space_fermionIDp10IndexTypesEDpRR10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_fermion.hpp&gt;</em></p>
<p>Make an elementary space associated with fermionic algebra generators
with given indices.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute10libcommute15dynamic_indices18make_space_fermionE24elementary_space_fermionI11dyn_indicesEDpRR10IndexTypes">
<span id="_CPPv3IDpEN10libcommute10libcommute15dynamic_indices18make_space_fermionEDpRR10IndexTypes"></span><span id="_CPPv2IDpEN10libcommute10libcommute15dynamic_indices18make_space_fermionEDpRR10IndexTypes"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute24elementary_space_fermionE" title="libcommute::elementary_space_fermion">elementary_space_fermion</a>&lt;dyn_indices&gt; <code class="sig-prename descclassname">libcommute::dynamic_indices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">make_space_fermion</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices18make_space_fermionE24elementary_space_fermionI11dyn_indicesEDpRR10IndexTypes" title="libcommute::libcommute::dynamic_indices::make_space_fermion::IndexTypes">IndexTypes</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices18make_space_fermionE24elementary_space_fermionI11dyn_indicesEDpRR10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_fermion.hpp&gt;</em></p>
<p>Make an elementary space associated with fermionic algebra generators
with a given dynamic index sequence.</p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IDpEN10libcommute22elementary_space_bosonE">
<span id="_CPPv3IDpEN10libcommute22elementary_space_bosonE"></span><span id="_CPPv2IDpEN10libcommute22elementary_space_bosonE"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">elementary_space_boson</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute22elementary_space_bosonE" title="libcommute::elementary_space_boson::IndexTypes">IndexTypes</a>...&gt;<a class="headerlink" href="#_CPPv4IDpEN10libcommute22elementary_space_bosonE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_boson.hpp&gt;</em></p>
<p>An elementary space associated with bosonic algebra generators. This
elementary space is truncated and can have an arbitrary dimension of
form <span class="math notranslate nohighlight">\(2^b\)</span>.</p>
<p class="rubric">Part of the interface not inherited from / identical to
<a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">elementary_space</span></code></a>.</p>
<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute22elementary_space_boson22elementary_space_bosonEiDpRR4Args">
<span id="_CPPv3IDpEN10libcommute22elementary_space_boson22elementary_space_bosonEiDpRR4Args"></span><span id="_CPPv2IDpEN10libcommute22elementary_space_boson22elementary_space_bosonEiDpRR4Args"></span>template&lt;typename ...<code class="sig-name descname">Args</code>&gt;<br /><code class="sig-name descname">elementary_space_boson</code><span class="sig-paren">(</span>int <em>n_bits</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute22elementary_space_boson22elementary_space_bosonEiDpRR4Args" title="libcommute::elementary_space_boson::elementary_space_boson::Args">Args</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute22elementary_space_boson22elementary_space_bosonEiDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>Construct a bosonic elementary space of dimension <span class="math notranslate nohighlight">\(2^\text{n_bits}\)</span>.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute10libcommute14static_indices16make_space_bosonE22elementary_space_bosonIDp10IndexTypesEiDpRR10IndexTypes">
<span id="_CPPv3IDpEN10libcommute10libcommute14static_indices16make_space_bosonEiDpRR10IndexTypes"></span><span id="_CPPv2IDpEN10libcommute10libcommute14static_indices16make_space_bosonEiDpRR10IndexTypes"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute22elementary_space_bosonE" title="libcommute::elementary_space_boson">elementary_space_boson</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices16make_space_bosonE22elementary_space_bosonIDp10IndexTypesEiDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_boson::IndexTypes">IndexTypes</a>...&gt; <code class="sig-prename descclassname">libcommute::static_indices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">make_space_boson</code><span class="sig-paren">(</span>int <em>n_bits</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices16make_space_bosonE22elementary_space_bosonIDp10IndexTypesEiDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_boson::IndexTypes">IndexTypes</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices16make_space_bosonE22elementary_space_bosonIDp10IndexTypesEiDpRR10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_boson.hpp&gt;</em></p>
<p>Make an elementary space of dimension <span class="math notranslate nohighlight">\(2^\text{n_bits}\)</span> associated with
bosonic algebra generators with given indices.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute10libcommute15dynamic_indices16make_space_bosonE22elementary_space_bosonI11dyn_indicesEiDpRR10IndexTypes">
<span id="_CPPv3IDpEN10libcommute10libcommute15dynamic_indices16make_space_bosonEiDpRR10IndexTypes"></span><span id="_CPPv2IDpEN10libcommute10libcommute15dynamic_indices16make_space_bosonEiDpRR10IndexTypes"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute22elementary_space_bosonE" title="libcommute::elementary_space_boson">elementary_space_boson</a>&lt;dyn_indices&gt; <code class="sig-prename descclassname">libcommute::dynamic_indices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">make_space_boson</code><span class="sig-paren">(</span>int <em>n_bits</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices16make_space_bosonE22elementary_space_bosonI11dyn_indicesEiDpRR10IndexTypes" title="libcommute::libcommute::dynamic_indices::make_space_boson::IndexTypes">IndexTypes</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices16make_space_bosonE22elementary_space_bosonI11dyn_indicesEiDpRR10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_boson.hpp&gt;</em></p>
<p>Make an elementary space of dimension <span class="math notranslate nohighlight">\(2^\text{n_bits}\)</span> associated with
bosonic algebra generators with a given dynamic index sequence.</p>
</dd></dl>

<dl class="cpp class">
<dt id="_CPPv4IDpEN10libcommute21elementary_space_spinE">
<span id="_CPPv3IDpEN10libcommute21elementary_space_spinE"></span><span id="_CPPv2IDpEN10libcommute21elementary_space_spinE"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">elementary_space_spin</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space">elementary_space</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute21elementary_space_spinE" title="libcommute::elementary_space_spin::IndexTypes">IndexTypes</a>...&gt;<a class="headerlink" href="#_CPPv4IDpEN10libcommute21elementary_space_spinE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_spin.hpp&gt;</em></p>
<p>An elementary space associated with spin algebra generators. Dimension of
this elementary space depends on spin <span class="math notranslate nohighlight">\(S\)</span>, and is computed as
<span class="math notranslate nohighlight">\(2S+1\)</span> rounded up to the nearest power of 2.</p>
<p class="rubric">Part of the interface not inherited from / identical to
<a class="reference internal" href="#_CPPv4IDpEN10libcommute16elementary_spaceE" title="libcommute::elementary_space"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">elementary_space</span></code></a>.</p>
<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute21elementary_space_spin21elementary_space_spinEdDpRR4Args">
<span id="_CPPv3IDpEN10libcommute21elementary_space_spin21elementary_space_spinEdDpRR4Args"></span><span id="_CPPv2IDpEN10libcommute21elementary_space_spin21elementary_space_spinEdDpRR4Args"></span>template&lt;typename ...<code class="sig-name descname">Args</code>&gt;<br /><code class="sig-name descname">elementary_space_spin</code><span class="sig-paren">(</span>double <em>spin</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute21elementary_space_spin21elementary_space_spinEdDpRR4Args" title="libcommute::elementary_space_spin::elementary_space_spin::Args">Args</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute21elementary_space_spin21elementary_space_spinEdDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a spin elementary space with a given spin <span class="math notranslate nohighlight">\(S\)</span> = <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4IDpEN10libcommute21elementary_space_spin21elementary_space_spinEdDpRR4Args" title="libcommute::elementary_space_spin::elementary_space_spin::spin"><span class="pre">spin</span></a></code>.</p>
</dd></dl>

</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute10libcommute14static_indices15make_space_spinE21elementary_space_spinIDp10IndexTypesEdDpRR10IndexTypes">
<span id="_CPPv3IDpEN10libcommute10libcommute14static_indices15make_space_spinEdDpRR10IndexTypes"></span><span id="_CPPv2IDpEN10libcommute10libcommute14static_indices15make_space_spinEdDpRR10IndexTypes"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute21elementary_space_spinE" title="libcommute::elementary_space_spin">elementary_space_spin</a>&lt;<a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices15make_space_spinE21elementary_space_spinIDp10IndexTypesEdDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_spin::IndexTypes">IndexTypes</a>...&gt; <code class="sig-prename descclassname">libcommute::static_indices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">make_space_spin</code><span class="sig-paren">(</span>double <em>spin</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices15make_space_spinE21elementary_space_spinIDp10IndexTypesEdDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_spin::IndexTypes">IndexTypes</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices15make_space_spinE21elementary_space_spinIDp10IndexTypesEdDpRR10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_spin.hpp&gt;</em></p>
<p>Make a spin elementary space with <span class="math notranslate nohighlight">\(S\)</span> = <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute14static_indices15make_space_spinE21elementary_space_spinIDp10IndexTypesEdDpRR10IndexTypes" title="libcommute::libcommute::static_indices::make_space_spin::spin"><span class="pre">spin</span></a></code> and given indices.</p>
</dd></dl>

<dl class="cpp function">
<dt id="_CPPv4IDpEN10libcommute10libcommute15dynamic_indices15make_space_spinE21elementary_space_spinI11dyn_indicesEdDpRR10IndexTypes">
<span id="_CPPv3IDpEN10libcommute10libcommute15dynamic_indices15make_space_spinEdDpRR10IndexTypes"></span><span id="_CPPv2IDpEN10libcommute10libcommute15dynamic_indices15make_space_spinEdDpRR10IndexTypes"></span>template&lt;typename ...<code class="sig-name descname">IndexTypes</code>&gt;<br /><a class="reference internal" href="#_CPPv4IDpEN10libcommute21elementary_space_spinE" title="libcommute::elementary_space_spin">elementary_space_spin</a>&lt;dyn_indices&gt; <code class="sig-prename descclassname">libcommute::dynamic_indices<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">make_space_spin</code><span class="sig-paren">(</span>double <em>spin</em>, <a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices15make_space_spinE21elementary_space_spinI11dyn_indicesEdDpRR10IndexTypes" title="libcommute::libcommute::dynamic_indices::make_space_spin::IndexTypes">IndexTypes</a>&amp;&amp;... <em>indices</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices15make_space_spinE21elementary_space_spinI11dyn_indicesEdDpRR10IndexTypes" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/elementary_space_spin.hpp&gt;</em></p>
<p>Make a spin elementary space with <span class="math notranslate nohighlight">\(S\)</span> = <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4IDpEN10libcommute10libcommute15dynamic_indices15make_space_spinE21elementary_space_spinI11dyn_indicesEdDpRR10IndexTypes" title="libcommute::libcommute::dynamic_indices::make_space_spin::spin"><span class="pre">spin</span></a></code> and a given
dynamic index sequence.</p>
</dd></dl>

</div>
<div class="section" id="advanced-customization-of-automatic-hilbert-space-construction">
<span id="es-constructor"></span><h2>Advanced: Customization of automatic Hilbert space construction<a class="headerlink" href="#advanced-customization-of-automatic-hilbert-space-construction" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> delegates the task of translating algebra
generators into elementary spaces to the functor passed as its second (optional)
argument. It is possible to customize the translation process by giving
<a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> a callable object similar to the following one</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// A custom elementary space constructor object</span>
<span class="k">struct</span> <span class="nc">my_es_constructor</span> <span class="p">{</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">IndexTypes</span><span class="o">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">elementary_space</span><span class="o">&lt;</span><span class="n">IndexTypes</span><span class="p">...</span><span class="o">&gt;&gt;</span>
  <span class="k">operator</span><span class="p">()(</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">IndexTypes</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Create an elementary space associated with &#39;g&#39; and return it</span>
    <span class="c1">// wrapped in a unique pointer.</span>
    <span class="c1">//</span>
  <span class="p">}</span>

  <span class="c1">// Other members if needed ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This approach gives total control over elementary space creation. It works best
when expressions to be translated do not mix too many algebras and the body
of <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">my_es_constructor</span><span class="pre">::</span><code class="sig-prename descclassname"><span class="pre">operator()</span></code></code> can be kept relatively simple.</p>
<p>Now imagine a different, more common situation, when expressions mix generators
of various predefined algebras as well as generators of a new user-defined
algebra <code class="docutils literal notranslate"><span class="pre">my_algebra</span></code>. It would be desirable to instruct
<a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> how to translate instances of
<code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">generator_my_algebra</span></code> into <code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">elementary_space_my_algebra</span></code> without
rewriting all the code needed to processed the predefined generators. This goal
can be achieved in a few steps by means of a special utility class
<a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">es_constructor</span></code></a>.</p>
<dl class="cpp class">
<dt id="_CPPv4I_DpiEN10libcommute14es_constructorE">
<span id="_CPPv3I_DpiEN10libcommute14es_constructorE"></span><span id="_CPPv2I_DpiEN10libcommute14es_constructorE"></span>template&lt;int... <code class="sig-name descname">AlgebraIDs</code>&gt;<br /><em class="property">class </em><code class="sig-name descname">es_constructor</code><a class="headerlink" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><em>Defined in &lt;libcommute/loperator/es_constructor.hpp&gt;</em></p>
</dd></dl>

<ul>
<li><p>Define a new algebra ID, e.g. <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">my_algebra_id</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// A unique integer &gt;=LIBCOMMUTE_MIN_USER_DEFINED_ALGEBRA_ID</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">my_algebra_id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p>Specialize class <a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">libcommute::es_constructor</span></code></a> as follows</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;&gt;</span> <span class="k">class</span> <span class="nc">es_constructor</span><span class="o">&lt;</span><span class="n">my_algebra_id</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>

  <span class="n">es_constructor</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">IndexTypes</span><span class="o">&gt;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">elementary_space</span><span class="o">&lt;</span><span class="n">IndexTypes</span><span class="p">...</span><span class="o">&gt;&gt;</span>
  <span class="k">operator</span><span class="p">()(</span><span class="n">generator</span><span class="o">&lt;</span><span class="n">IndexTypes</span><span class="p">...</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">//</span>
    <span class="c1">// Create an elementary space associated with &#39;g&#39; and return it</span>
    <span class="c1">// wrapped in a unique pointer. This method will be called only for</span>
    <span class="c1">// the generators of the new algebra, i.e. only when</span>
    <span class="c1">// g.algebra_id() == my_algebra_id</span>
    <span class="c1">//</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">es_constructor</span></code> is obviously a valid elementary space
constructor for <code class="docutils literal notranslate"><span class="pre">my_algebra</span></code></p>
</li>
<li><p>Instantiate <a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><code class="xref cpp cpp-type docutils literal notranslate"><span class="pre">es_constructor</span></code></a> with multiple template parameters
(algebra IDs).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">es_constr</span> <span class="o">=</span> <span class="n">es_constructor</span><span class="o">&lt;</span><span class="n">fermion</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">my_algebra_id</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>Now, <code class="xref cpp cpp-expr docutils literal notranslate"><span class="pre">es_constr</span></code> knows how to process
<a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute7fermionE" title="libcommute::fermion"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">fermionic</span></code></a>,
<a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute4spinE" title="libcommute::spin"><code class="xref cpp cpp-var docutils literal notranslate"><span class="pre">spin</span></code></a> and <code class="docutils literal notranslate"><span class="pre">my_algebra</span></code> generators.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The algebra IDs must come in the ascending order when used as
template parameters of <a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">es_constructor</span></code></a>.</p>
</div>
</li>
<li><p>Finally, call <a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> with two arguments.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">hs</span> <span class="o">=</span> <span class="n">make_hilbert_space</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">es_constr</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
<p>It is worth noting that by default <a class="reference internal" href="#_CPPv4I0Dp0EN10libcommute18make_hilbert_spaceE13hilbert_spaceIDp10IndexTypesERK10expressionI10ScalarTypeDp10IndexTypesERR13ESConstructor" title="libcommute::make_hilbert_space"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">make_hilbert_space()</span></code></a> uses the
following constructor type as its second argument.</p>
<dl class="cpp type">
<dt id="_CPPv4N10libcommute22default_es_constructorE">
<span id="_CPPv3N10libcommute22default_es_constructorE"></span><span id="_CPPv2N10libcommute22default_es_constructorE"></span><em class="property">using </em><code class="sig-name descname">default_es_constructor</code> = <a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor">es_constructor</a>&lt;<a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute7fermionE" title="libcommute::fermion">fermion</a>, <a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute4spinE" title="libcommute::spin">spin</a>&gt;<a class="headerlink" href="#_CPPv4N10libcommute22default_es_constructorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<p>In other words, it recognizes only fermionic and spin generators, and throws
<code class="xref cpp cpp-struct docutils literal notranslate"><span class="pre">es_construction_failure</span></code> for all other algebra IDs. If there are
bosonic creation/annihilation operators found in the expression, one may
use another elementary space constructor,</p>
<dl class="cpp type">
<dt id="_CPPv4N10libcommute20boson_es_constructorE">
<span id="_CPPv3N10libcommute20boson_es_constructorE"></span><span id="_CPPv2N10libcommute20boson_es_constructorE"></span><em class="property">using </em><code class="sig-name descname">boson_es_constructor</code> = <a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor">es_constructor</a>&lt;<a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute7fermionE" title="libcommute::fermion">fermion</a>, <a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute5bosonE" title="libcommute::boson">boson</a>, <a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute4spinE" title="libcommute::spin">spin</a>&gt;<a class="headerlink" href="#_CPPv4N10libcommute20boson_es_constructorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling
<code class="docutils literal notranslate"><span class="pre">es_constructor&lt;ID1,</span> <span class="pre">ID2,</span> <span class="pre">...,</span> <span class="pre">IDN&gt;(arg1,</span> <span class="pre">arg2,</span> <span class="pre">...,</span> <span class="pre">argK)</span></code>
will internally construct a series of objects
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><span class="pre">ID1</span><span class="pre">&gt;</span></code>, <code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><span class="pre">ID2</span><span class="pre">&gt;</span></code>, …,
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><span class="pre">IDN</span><span class="pre">&gt;</span></code>. The arguments will be ‘fed’ into
constructors of the single-ID objects in order, <em>at most one
argument per constructor</em>. For example,
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute7fermionE" title="libcommute::fermion"><span class="pre">fermion</span></a><span class="pre">,</span> <a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute5bosonE" title="libcommute::boson"><span class="pre">boson</span></a><span class="pre">,</span> <a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute4spinE" title="libcommute::spin"><span class="pre">spin</span></a><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">4</span><span class="pre">)</span></code> will call
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute7fermionE" title="libcommute::fermion"><span class="pre">fermion</span></a><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">)</span></code>,
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute5bosonE" title="libcommute::boson"><span class="pre">boson</span></a><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">4</span><span class="pre">)</span></code> and
<code class="xref cpp cpp-expr docutils literal notranslate"><a class="reference internal" href="#_CPPv4I_DpiEN10libcommute14es_constructorE" title="libcommute::es_constructor"><span class="pre">es_constructor</span></a><span class="pre">&lt;</span><a class="reference internal" href="../expression/generator.html#_CPPv4N10libcommute4spinE" title="libcommute::spin"><span class="pre">spin</span></a><span class="pre">&gt;</span><span class="pre">(</span><span class="pre">)</span></code> because the bosonic constructor is the
first in the sequence accepting one argument.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="loperator.html" class="btn btn-neutral float-right" title="Linear operators" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="intro.html" class="btn btn-neutral float-left" title="Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2016-2020, Igor Krivenko

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>